<!DOCTYPE html>




<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <title>idtxl package &mdash; IDTxl 0.1 documentation</title>
    <meta name="description" content="">
    <meta name="author" content="">

    

<link rel="stylesheet" href="_static/css/basicstrap-base.css" type="text/css" />
<link rel="stylesheet" id="current-theme" href="_static/css/bootstrap3/bootswatch-spacelab.css" type="text/css" />
<link rel="stylesheet" id="current-adjust-theme" href="_static/css/adjust_theme/bootswatch-spacelab.css" type="text/css" />

<link rel="stylesheet" href="_static/css/font-awesome.min.css">

<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 40px;
  }
</style>

<link rel="stylesheet" href="_static/css/basicstrap.css" type="text/css" />
<link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
            URL_ROOT:    './',
            VERSION:     '0.1',
            COLLAPSE_INDEX: false,
            FILE_SUFFIX: '.html',
            HAS_SOURCE:  true
  };
</script>
    <script type="text/javascript" src="_static/js/jquery.min.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/bootstrap3.min.js"></script>
<script type="text/javascript" src="_static/js/jquery.cookie.min.js"></script>
<script type="text/javascript" src="_static/js/basicstrap.js"></script>
<script type="text/javascript">
</script>
    <link rel="top" title="IDTxl 0.1 documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div id="navbar-top" class="navbar navbar-fixed-top navbar-default" role="navigation" aria-label="top navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">IDTxl 0.1 documentation</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
              <li class="dropdown visible-xs">
                <a role="button" id="localToc" data-toggle="dropdown" data-target="#" href="#">Table Of Contents <b class="caret"></b></a>
                <ul class="dropdown-menu localtoc sp-localtoc" role="menu" aria-labelledby="localToc">
                <ul>
<li><a class="reference internal" href="#">idtxl package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_te">idtxl.bivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.data">idtxl.data module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_ais">idtxl.estimators_ais module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_cmi">idtxl.estimators_cmi module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_fast_pid">idtxl.estimators_fast_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_fast_pid_ext_rep">idtxl.estimators_fast_pid_ext_rep module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_mi">idtxl.estimators_mi module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_pid">idtxl.estimators_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_te">idtxl.estimators_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.ft2idtxl">idtxl.ft2idtxl module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_exceptions">idtxl.idtxl_exceptions module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_io">idtxl.idtxl_io module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_utils">idtxl.idtxl_utils module</a></li>
<li><a class="reference internal" href="#module-idtxl.matarray2idtxl">idtxl.matarray2idtxl module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_te">idtxl.multivariate_te module</a></li>
<li><a class="reference internal" href="#idtxl-neighbour-search-cuda-module">idtxl.neighbour_search_cuda module</a></li>
<li><a class="reference internal" href="#module-idtxl.neighbour_search_opencl">idtxl.neighbour_search_opencl module</a></li>
<li><a class="reference internal" href="#module-idtxl.neighbour_search_opencl_old">idtxl.neighbour_search_opencl_old module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_analysis">idtxl.network_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_comparison">idtxl.network_comparison module</a></li>
<li><a class="reference internal" href="#module-idtxl.pyinfo">idtxl.pyinfo module</a></li>
<li><a class="reference internal" href="#module-idtxl.set_estimator">idtxl.set_estimator module</a></li>
<li><a class="reference internal" href="#module-idtxl.single_process_storage">idtxl.single_process_storage module</a></li>
<li><a class="reference internal" href="#module-idtxl.stats">idtxl.stats module</a></li>
<li><a class="reference internal" href="#module-idtxl.surrogates">idtxl.surrogates module</a></li>
<li><a class="reference internal" href="#module-idtxl.visualise_graph">idtxl.visualise_graph module</a></li>
<li><a class="reference internal" href="#module-idtxl">Module contents</a></li>
</ul>
</li>
</ul>

                </ul>
              </li>

            
              <li><a href="py-modindex.html" title="Python Module Index" >modules </a></li>
              <li><a href="genindex.html" title="General Index" accesskey="I">index </a></li>
            
            <li class="visible-xs"><a href="_sources/idtxl.txt" rel="nofollow">Show Source</a></li>

            <li class="visible-xs">
                <form class="search form-search form-inline navbar-form navbar-right sp-searchbox" action="search.html" method="get">
                  <div class="input-append input-group">
                    <input type="text" class="search-query form-control" name="q" placeholder="Search...">
                    <span class="input-group-btn">
                    <input type="submit" class="btn" value="Go" />
                    </span>
                  </div>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </li>

            

          </ul>

        </div>
      </div>
    </div>
    

    <!-- container -->
    <div class="container">

      <!-- row -->
      <div class="row">
        
        

        <div class="col-md-9" id="content-wrapper">
          <div class="document" role="main">
            <div class="documentwrapper">
              <div class="bodywrapper">
                <div class="body">
                  
  <div class="section" id="idtxl-package">
<h1>idtxl package<a class="headerlink" href="#idtxl-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-idtxl.bivariate_te">
<span id="idtxl-bivariate-te-module"></span><h2>idtxl.bivariate_te module<a class="headerlink" href="#module-idtxl.bivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Estimate bivariate transfer entropy.</p>
<p>Calculate bivariate transfer entropy (TE) using the maximum statistic.</p>
<p>Created on Wed Apr 06 17:58:31 2016</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.bivariate_te.Bivariate_te">
<em class="property">class </em><tt class="descclassname">idtxl.bivariate_te.</tt><tt class="descname">Bivariate_te</tt><big>(</big><em>max_lag_sources</em>, <em>min_lag_sources</em>, <em>max_lag_target</em>, <em>tau_sources=1</em>, <em>tau_target=1</em>, <em>options=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/bivariate_te.html#Bivariate_te"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.bivariate_te.Bivariate_te" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.Network_analysis" title="idtxl.network_analysis.Network_analysis"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.network_analysis.Network_analysis</span></tt></a></p>
<p>Set up a network analysis using bivariate transfer entropy.</p>
<p>Set parameters necessary for network inference using transfer entropy (TE).
To perform network inference call analyse_network() on an instance of the
data class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>max_lag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth</dd>
<dt>min_lag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>minimum temporal search depth</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for estimator use and statistics:</p>
<ul class="last simple">
<li>&#8216;n_perm_*&#8217; - number of permutations, where * can be &#8216;max_stat&#8217;,</li>
<li>&#8216;min_stat&#8217;, &#8216;omnibus&#8217;, and &#8216;max_seq&#8217; (default=500)</li>
<li>&#8216;alpha_*&#8217; - critical alpha level for statistical significance,
where * can be &#8216;max_stats&#8217;,  &#8216;min_stats&#8217;, and &#8216;omnibus&#8217;
(default=0.05)</li>
<li>&#8216;cmi_calc_name&#8217; - estimator to be used for CMI calculation
(For estimator options see the respective documentation.)</li>
<li>&#8216;add_conditionals&#8217; - force the estimator to add these
conditionals when estimating TE; can either be a list of
variables, where each variable is described as (idx process, lag
wrt to current value) or can be a string: &#8216;faes&#8217; for Faes-Method</li>
</ul>
</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>samples in the full conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_sources <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>source samples in the conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_target <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>target samples in the conditional set, (idx process, idx sample)</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value in TE estimation, (idx process,
idx sample)</dd>
<dt>calculator_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>calculator used for TE estimation</dd>
<dt>max_lag_target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth for candidates in the target&#8217;s past
(default=same as max_lag_sources)</dd>
<dt>max_lag_sources <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth for candidates in the sources&#8217; past</dd>
<dt>min_lag_sources <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>minimum temporal search depth for candidates in the sources&#8217; past</dd>
<dt>pvalue_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>p-value of the omnibus test</dd>
<dt>pvalues_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>array of p-values for TE from individual sources to the target</dd>
<dt>te_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>joint TE from all sources to the target</dd>
<dt>te_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>raw TE values from individual sources to the target</dd>
<dt>sign_ominbus <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>statistical significance of the over-all TE</dd>
<dt>source_set <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list with indices of source processes</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>index of target process</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.bivariate_te.Bivariate_te.analyse_network">
<tt class="descname">analyse_network</tt><big>(</big><em>data</em>, <em>targets='all'</em>, <em>sources='all'</em><big>)</big><a class="reference internal" href="_modules/idtxl/bivariate_te.html#Bivariate_te.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.bivariate_te.Bivariate_te.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between all nodes in the network.</p>
<p>Estimate bivariate transfer entropy between provided sources and
each target. Custom source sets can be provided for each target, as
lists of lists of nodes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_lag</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_lag</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">analysis_opts</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;cmi_calc_name&#39;</span><span class="p">:</span> <span class="s">&#39;jidt_kraskov&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">Bivariate_te</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">analysis_opts</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                <span class="n">min_lag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>For more details on the estimation of bivariate transfer entropy
see documentation of class method &#8216;analyse_single_target&#8217;.</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd>index of target processes</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | list of list | &#8216;all&#8217;</span></dt>
<dd>indices of source processes for each target;
if &#8216;all&#8217;, all sources are tested for each target;
if list of int, sources specified in the list are tested for
each target;
if list of list, sources specified in each inner list are
tested for the corresponding target</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.bivariate_te.Bivariate_te.analyse_single_target">
<tt class="descname">analyse_single_target</tt><big>(</big><em>data</em>, <em>target</em>, <em>sources='all'</em><big>)</big><a class="reference internal" href="_modules/idtxl/bivariate_te.html#Bivariate_te.analyse_single_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.bivariate_te.Bivariate_te.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between sources and a target.</p>
<p>Find bivariate transfer entropy between all source processes and the
target process. Uses bivariate, non-uniform embedding found through
information maximisation (see Faes, ???, and Lizier, 2012). This is
done in four steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li>find all relevant samples in the target processes&#8217; own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</li>
<li>find all relevant samples in the source processes&#8217; pasts (again
by finding all candidates with significant CMI)</li>
<li>prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</li>
<li>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual samples in the set)</li>
</ol>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of target process</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int, int, or &#8216;all&#8217;</span></dt>
<dd>single index or list of indices of source processes, if &#8216;all&#8217;,
all possible sources for the given target are tested</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results consisting of
conditional sets (full, from sources, from target),
results for omnibus test (joint influence of source cands.),
pvalues for each significant source candidate</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.data">
<span id="idtxl-data-module"></span><h2>idtxl.data module<a class="headerlink" href="#module-idtxl.data" title="Permalink to this headline">¶</a></h2>
<p>Provide data structures for IDTxl analysis.</p>
<p>Created on Mon Mar  7 18:13:27 2016</p>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.data.Data">
<em class="property">class </em><tt class="descclassname">idtxl.data.</tt><tt class="descname">Data</tt><big>(</big><em>data=None</em>, <em>dim_order='psr'</em>, <em>normalise=True</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Store data for information dynamics estimation.</p>
<p>Data takes a 1- to 3-dimensional array representing realisations of random
variables in dimensions: processes, samples (over time), and replications.
If necessary, data reshapes provided realisations to fit the format
expected by IDTxl, which is a 3-dimensional array with axes representing
(process index, sample index, replication index). Indicate the actual order
of dimensions in the provided array in a three-character string, e.g. &#8216;spr&#8217;
for an array with realisations over (1) samples in time, (2) processes, (3)
replications.</p>
<dl class="docutils">
<dt>Examples:</dt>
<dd>d_mute = Data()              # initialise empty data object
d_mute.generate_mute_data()  # simulate data from MuTE paper
dat = np.arange(10000).reshape((2, 1000, 5))  # random data: 2 procs.,
d1 = Data(dat, dim_order=&#8217;psr&#8217;)               # 1000 samples, 5 repl.
dat = np.arange(3000).reshape((3, 1000))  # random data: 3 procs.,
d2 = Data(dat, dim_order=&#8217;ps&#8217;)            # 1000 samples
dat_new = np.arange(5000)
d2.set_data(dat_new, &#8216;s&#8217;)  # set new data for the existing object</dd>
<dt>Note:</dt>
<dd>Realisations are stored as attribute &#8216;data&#8217;. This can&#8217;t be set
directly, but only via the method &#8216;set_data&#8217;</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>1/2/3-dimensional array with raw data</dd>
<dt>dim_order <span class="classifier-delimiter">:</span> <span class="classifier">string [optional]</span></dt>
<dd>order of dimensions, accepts any combination of the characters
&#8216;p&#8217;, &#8216;s&#8217;, and &#8216;r&#8217; for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., &#8216;ps&#8217; for a
two-dimensional array of data from several processes over time
(default=&#8217;psr&#8217;)</dd>
<dt>normalise <span class="classifier-delimiter">:</span> <span class="classifier">bool [optional]</span></dt>
<dd>if True, data gets normalised per process (default=True)</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations, can only be set via &#8216;set_data&#8217; method</dd>
<dt>n_processes <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of processes</dd>
<dt>n_replications <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of replications</dd>
<dt>n_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples in time</dd>
<dt>normalise <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if true, all data gets z-standardised per process</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="idtxl.data.Data.data">
<tt class="descname">data</tt><a class="reference internal" href="_modules/idtxl/data.html#Data.data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data array.</p>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.generate_mute_data">
<tt class="descname">generate_mute_data</tt><big>(</big><em>n_samples=1000</em>, <em>n_replications=10</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_mute_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.generate_mute_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate example data for a 5-process network.</p>
<p>Generate example data and overwrite the instance&#8217;s current data. The
network is used as an example the paper on the MuTE toolbox (Montalto,
PLOS ONE, 2014, eq. 14). The network consists of five autoregressive
(AR) processes with model orders 2 and les and the following
(non-linear) couplings:</p>
<p>0 -&gt; 1, u = 2
0 -&gt; 2, u = 3
0 -&gt; 3, u = 2 (non-linear)
3 -&gt; 4, u = 1
4 -&gt; 3, u = 1</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>n_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples simulated for each process and replication</dd>
<dt>n_replications <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of replications</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.get_realisations">
<tt class="descname">get_realisations</tt><big>(</big><em>current_value</em>, <em>idx_list</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.get_realisations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.get_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return all realisations of a random variable in the data.</p>
<p>Return realisations of random variables represented by a list of
indices. An index is expected to have the form (process index, sample
index). The analysis_setup contains information like for example the
current_value in TE analysis, which are needed to identify variable
realisations in the raw data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current_value in the data</dd>
<dt>idx_list <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of variables</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>realisations with dimensions replications x number of indices</dd>
<dt>numpy array</dt>
<dd>replication index for each realisation</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd><dl class="first last docutils">
<dt>TypeError</dt>
<dd>If idx is not a list</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.n_realisations">
<tt class="descname">n_realisations</tt><big>(</big><em>current_value=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples and replications.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple [optional]</span></dt>
<dd>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, we count
realisations from the k+1th sample because we loose the first k
samples to the embedding); if no current_value is provided, the
number of all samples is used</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.n_realisations_repl">
<tt class="descname">n_realisations_repl</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_repl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_repl" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over replications.</p>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.n_realisations_samples">
<tt class="descname">n_realisations_samples</tt><big>(</big><em>current_value=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple [optional]</span></dt>
<dd>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, the current value is
at sample k + 1; we thus count realisations from the k + 1st
sample because we loose the first k samples to the embedding)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.permute_replications">
<tt class="descname">permute_replications</tt><big>(</big><em>current_value</em>, <em>idx_list</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_replications"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.permute_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted replications (time stays intact).</p>
<p>Create surrogate data by permuting realisations over replications while
keeping the temporal structure (order of samples) intact. Return
realisations for all indices in the list, where an index is expected to
have the form (process index, sample index). Realisations are permuted
block-wise by permuting the order of replications:</p>
<dl class="docutils">
<dt>original data:</dt>
<dd>rep.:   1 1 1 1  2 2 2 2  3 3 3 3  4 4 4 4  5 5 5 5  6 6 6 6 ...
sample: 1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4 ...</dd>
<dt>permuted data:</dt>
<dd>rep.:   3 3 3 3  1 1 1 1  4 4 4 4  6 6 6 6  2 2 2 2  5 5 5 5 ...
sample: 1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4 ...</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current_value in the data</dd>
<dt>idx_list <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of variables</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>permuted realisations with dimensions replications x number of
indices</dd>
<dt>numpy array</dt>
<dd>replication index for each realisation</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>TypeError if idx_realisations is not a list</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.permute_samples">
<tt class="descname">permute_samples</tt><big>(</big><em>current_value</em>, <em>idx_list</em>, <em>perm_range='max'</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.permute_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted samples (repl. stays intact).</p>
<p>Create surrogate data by permuting realisations over samples (time)
while keeping the order of replications intact. Return realisations for
all indices in the list, where an index is expected to have the form
(process index, sample index). Realisations are permuted sample-wise or
within a permutation range (perm_range). If no permutation range is
given, samples are randomly permuted over the whole replication, i.e.,
over all time indices in the replication:</p>
<dl class="docutils">
<dt>original data:</dt>
<dd>rep.:   1 1 1 1  2 2 2 2  3 3 3 3  4 4 4 4  5 5 5 5  6 6 6 6 ...
sample: 1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4 ...</dd>
<dt>permuted data (perm_range=&#8217;max&#8217;):</dt>
<dd>rep.:   1 1 1 1  2 2 2 2  3 3 3 3  4 4 4 4  5 5 5 5  6 6 6 6 ...
sample: 4 1 3 2  1 3 4 2  4 3 2 1  1 2 4 3  2 4 3 1  1 3 4 2 ...</dd>
<dt>permuted data (perm_range=2):</dt>
<dd>rep.:   1 1 1 1  2 2 2 2  3 3 3 3  4 4 4 4  5 5 5 5  6 6 6 6 ...
sample: 2 1 3 4  1 2 4 3  2 1 4 3  1 2 3 4  2 1 4 3  1 2 4 3 ...</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current_value in the data</dd>
<dt>idx_list <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of variables</dd>
<dt>perm_range <span class="classifier-delimiter">:</span> <span class="classifier">int or &#8216;max&#8217; [optional]</span></dt>
<dd>range over which realisations are permuted, if &#8216;max&#8217;
realisations are permuted over the whole replication, otherwise
realisations are permuted over blocks of length perm_range</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>permuted realisations with dimensions replications x number of
indices</dd>
<dt>numpy array</dt>
<dd>sample index for each realisation</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>TypeError if idx_realisations is not a list</dd>
<dt>Note:</dt>
<dd>This permutation scheme is the fall-back option if the number of
replications is too small to allow a sufficient number of
permutations for the generation of surrogate data.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.set_data">
<tt class="descname">set_data</tt><big>(</big><em>data</em>, <em>dim_order</em><big>)</big><a class="reference internal" href="_modules/idtxl/data.html#Data.set_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite data in an existing Data object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1- to 3-dimensional array of realisations</dd>
<dt>dim_order <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>order of dimensions, accepts any combination of the characters
&#8216;p&#8217;, &#8216;s&#8217;, and &#8216;r&#8217; for processes, samples, and replications;
must have the same length as number of dimensions in data</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_ais">
<span id="idtxl-estimators-ais-module"></span><h2>idtxl.estimators_ais module<a class="headerlink" href="#module-idtxl.estimators_ais" title="Permalink to this headline">¶</a></h2>
<p>Provide AIS estimators for the Estimator_ais class.</p>
<p>This module exports methods for active information storage (AIS) estimation in
the Estimator_ais class.</p>
<dl class="function">
<dt id="idtxl.estimators_ais.is_parallel">
<tt class="descclassname">idtxl.estimators_ais.</tt><tt class="descname">is_parallel</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_ais.html#is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_ais.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if estimator can estimate AIS for multiple chunks in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_ais.jidt_kraskov">
<tt class="descclassname">idtxl.estimators_ais.</tt><tt class="descname">jidt_kraskov</tt><big>(</big><em>self</em>, <em>process</em>, <em>opts</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_ais.html#jidt_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_ais.jidt_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate active information storage with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT&#8217;s
implementation of the Kraskov type 1 estimator. AIS is defined as the
mutual information between the processes&#8217; past state and current value.</p>
<p>The past state needs to be defined in the opts dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes&#8217; past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes&#8217; past.</p>
<p>References:</p>
<p>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012). Local
measures of information storage in complex distributed computation.
Information Sciences, 208, 39-54.</p>
<p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Physical review E, 69(6), 066138.</p>
<p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front. Robot. AI, 1(11).</p>
<p>This function is meant to be imported into the set_estimator module and
used as a method in the Estimator_cmi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_cmi</span></dt>
<dd>function is supposed to be used as part of the Estimator_cmi class</dd>
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the process</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;history&#8217; - number of samples in the processes&#8217; past to consider</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8217;ACT&#8217;, the autocorr. time of the target)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=1e-8)</li>
<li>&#8216;local_values&#8217; - return local AIS instead of average AIS
(default=False)</li>
<li>&#8216;tau&#8217; - the processes&#8217; embedding delay (default=1)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first docutils">
<dt>float</dt>
<dd>active information storage in the process</dd>
</dl>
<p>OR
numpy array of floats</p>
<blockquote class="last">
<div>local active information storage if local_values is set</div></blockquote>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS calculator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_cmi">
<span id="idtxl-estimators-cmi-module"></span><h2>idtxl.estimators_cmi module<a class="headerlink" href="#module-idtxl.estimators_cmi" title="Permalink to this headline">¶</a></h2>
<p>Provide CMI estimators for the Estimator_cmi class.</p>
<p>This module exports methods for conditional mutual information (CMI) estimation
in the Estimator_cmi class.</p>
<dl class="function">
<dt id="idtxl.estimators_cmi.is_parallel">
<tt class="descclassname">idtxl.estimators_cmi.</tt><tt class="descname">is_parallel</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_cmi.html#is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_cmi.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if estimator can estimate CMI for multiple chunks in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_cmi.jidt_discrete">
<tt class="descclassname">idtxl.estimators_cmi.</tt><tt class="descname">jidt_discrete</tt><big>(</big><em>self</em>, <em>var1</em>, <em>var2</em>, <em>conditional</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_cmi.html#jidt_discrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_cmi.jidt_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate CMI with JIDT&#8217;s implementation for discrete variables.</p>
<p>Calculate the conditional mutual information between two variables given
the third. Call JIDT via jpype and use the discrete estimator.</p>
<p>References:</p>
<p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front. Robot. AI, 1(11).</p>
<p>This function is ment to be imported into the set_estimator module and used
as a method in the Estimator_cmi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_cmi</span></dt>
<dd>function is supposed to be used as part of the Estimator_cmi class</dd>
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array (either of integers or doubles to be discretised)</span></dt>
<dd>realisations of the first random variable.
Can be multidimensional (i.e. multivariate) where dimensions of the
array are realisations x variable dimension</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array (either of integers or doubles to be discretised)</span></dt>
<dd>realisations of the second random variable.
Can be multidimensional (i.e. multivariate) where dimensions of the
array are realisations x variable dimension</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array (either of integers or doubles to be discretised)</span></dt>
<dd>realisations of the conditional random variable.
Can be multidimensional (i.e. multivariate) where dimensions of the
array are realisations x variable dimension</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:
- &#8216;num_discrete_bins&#8217; - number of discrete bins/levels or the base</p>
<blockquote>
<div>of each dimension of the discrete variables (default=2 for
binary). If this is set, then parameters &#8216;alph1&#8217;, &#8216;alph2&#8217; and
&#8216;alphc&#8217; are all set to this value</div></blockquote>
<ul class="last simple">
<li>&#8216;alph1&#8217; - number of discrete bins/levels for var1 (default=2 for
binary, or the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;alph2&#8217; - number of discrete bins/levels for var2 (default=2 for
binary, or the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;alphc&#8217; - number of discrete bins/levels for conditional
(default=2 for binary, or the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;discretise_method&#8217; - if and how to discretise incoming
continuous variables to discrete values.
&#8216;max_ent&#8217; means to use a maximum entropy binning
&#8216;equal&#8217; means to use equal size bins
&#8216;none&#8217; means variables are already discrete (default=&#8217;none&#8217;)</li>
<li>&#8216;debug&#8217; - set debug prints from the calculator on</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>conditional mutual information</dd>
</dl>
</dd>
</dl>
<p>Note:</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_cmi.jidt_kraskov">
<tt class="descclassname">idtxl.estimators_cmi.</tt><tt class="descname">jidt_kraskov</tt><big>(</big><em>self</em>, <em>var1</em>, <em>var2</em>, <em>conditional=None</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_cmi.html#jidt_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_cmi.jidt_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate conditional mutual infor with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate the conditional mutual information between three variables. Call
JIDT via jpype and use the Kraskov 1 estimator. If no conditional is given
(is None), the function returns the mutual information between var1 and
var2. References:</p>
<p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Physical review E, 69(6), 066138.</p>
<p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front. Robot. AI, 1(11).</p>
<p>This function is ment to be imported into the set_estimator module and used
as a method in the Estimator_cmi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_cmi</span></dt>
<dd>function is supposed to be used as part of the Estimator_cmi class</dd>
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the first random variable, where dimensions are
realisations x variable dimension</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second random variable</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of the random variable for conditioning, if no
conditional is provided, return MI between var1 and var2</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8217;ACT&#8217;, the autocorr. time of the target)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=1e-8)</li>
<li>&#8216;num_threads&#8217; - no. CPU threads used for estimation
(default=&#8217;USE_ALL&#8217;, this uses all available cores on the
machine!)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>conditional mutual information</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI calculator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_cmi.opencl_kraskov">
<tt class="descclassname">idtxl.estimators_cmi.</tt><tt class="descname">opencl_kraskov</tt><big>(</big><em>self</em>, <em>var1</em>, <em>var2</em>, <em>conditional=None</em>, <em>n_chunks=1</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_cmi.html#opencl_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_cmi.opencl_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate conditional mutual infor using opencl Kraskov implementation.</p>
<p>Calculate the conditional mutual information between three variables using
an opencl-based Kraskov type 1 estimator. References:</p>
<p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Physical review E, 69(6), 066138.</p>
<p>This function is ment to be imported into the set_estimator module and used
as a method in the Estimator_cmi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_cmi</span></dt>
<dd>function is supposed to be used as part of the Estimator_cmi class</dd>
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the first random variable, where dimensions are
realisations x variable dimension</dd>
<dt>var2: numpy array</dt>
<dd>realisations of the second random variable</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of the random variable for conditioning, if no
conditional is provided, return MI between var1 and var2</dd>
<dt>n_chunks <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>number of data sets or chunks (default=1)</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8217;ACT&#8217;, the autocorr. time of the target)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=1e-8)</li>
<li>&#8216;gpuid&#8217; - device ID (default=0)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>conditional mutual information</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>The Theiler window ignores trial boundaries. The CMI estimator does add
noise to the data as a default. To make analysis runs replicable set
noise_level to 0.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_fast_pid">
<span id="idtxl-estimators-fast-pid-module"></span><h2>idtxl.estimators_fast_pid module<a class="headerlink" href="#module-idtxl.estimators_fast_pid" title="Permalink to this headline">¶</a></h2>
<p>Provide a fast implementation of the PDI estimator for discrete data.</p>
<p>This module exports a fast implementation of the partial information
decomposition (PID) estimator for discrete data. The estimator does not require
JAVA or GPU modules to run.</p>
<dl class="function">
<dt id="idtxl.estimators_fast_pid.pid">
<tt class="descclassname">idtxl.estimators_fast_pid.</tt><tt class="descname">pid</tt><big>(</big><em>s1</em>, <em>s2</em>, <em>t</em>, <em>cfg</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_fast_pid.html#pid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_fast_pid.pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast implementation of the PID estimator.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_fast_pid_ext_rep">
<span id="idtxl-estimators-fast-pid-ext-rep-module"></span><h2>idtxl.estimators_fast_pid_ext_rep module<a class="headerlink" href="#module-idtxl.estimators_fast_pid_ext_rep" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="idtxl.estimators_fast_pid_ext_rep.pid">
<tt class="descclassname">idtxl.estimators_fast_pid_ext_rep.</tt><tt class="descname">pid</tt><big>(</big><em>s1</em>, <em>s2</em>, <em>t</em>, <em>cfg</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_fast_pid_ext_rep.html#pid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_fast_pid_ext_rep.pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a fast implementation of the PDI estimator for discrete data.</p>
<p>This module exports a fast implementation of the partial information
decomposition (PID) estimator for discrete data. The estimator does not require
JAVA or GPU modules to run.</p>
<p>Improved version with larger initial swaps and checking for convergence of both
the unique information from sources 1 and 2.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_mi">
<span id="idtxl-estimators-mi-module"></span><h2>idtxl.estimators_mi module<a class="headerlink" href="#module-idtxl.estimators_mi" title="Permalink to this headline">¶</a></h2>
<p>Provide mutual information estimators for the Estimator_mi class.</p>
<p>This module exports methods for mutual information (MI) estimation
in the Estimator_mi class.</p>
<dl class="function">
<dt id="idtxl.estimators_mi.is_parallel">
<tt class="descclassname">idtxl.estimators_mi.</tt><tt class="descname">is_parallel</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_mi.html#is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_mi.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if estimator can estimate CMI for multiple chunks in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_mi.jidt_discrete">
<tt class="descclassname">idtxl.estimators_mi.</tt><tt class="descname">jidt_discrete</tt><big>(</big><em>self</em>, <em>var1</em>, <em>var2</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_mi.html#jidt_discrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_mi.jidt_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mutual information with JIDT&#8217;s discrete-variable implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the discrete estimator.</p>
<p>References:</p>
<p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front. Robot. AI, 1(11).</p>
<p>This function is meant to be imported into the set_estimator module and used
as a method in the Estimator_mi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_mi</span></dt>
<dd>function is supposed to be used as part of the Estimator_mi class</dd>
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array (either of integers or doubles to be discretised)</span></dt>
<dd>realisations of the first random variable.
Can be multidimensional (i.e. multivariate) where dimensions of the
array are realisations x variable dimension</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array (either of integers or doubles to be discretised)</span></dt>
<dd>realisations of the second random variable.
Can be multidimensional (i.e. multivariate) where dimensions of the
array are realisations x variable dimension</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:
- &#8216;num_discrete_bins&#8217; - number of discrete bins/levels or the base of</p>
<blockquote>
<div>each dimension of the discrete variables (default=2 for binary)</div></blockquote>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;time_diff&#8217; - time difference across which to take MI from variable 1</dt>
<dd><p class="first last">to variable 2, i.e. lag from variable 1 to 2 (default=0)</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;discretise_method&#8217; - if and how to discretise incoming continuous variables</dt>
<dd><p class="first last">to discrete values.
&#8216;max_ent&#8217; means to use a maximum entropy binning
&#8216;equal&#8217; means to use equal size bins
&#8216;none&#8217; means variables are already discrete (default=&#8217;none&#8217;)</p>
</dd>
</dl>
</li>
<li><p class="first">&#8216;debug&#8217; - set debug prints from the calculator on</p>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>mutual information</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_mi.jidt_kraskov">
<tt class="descclassname">idtxl.estimators_mi.</tt><tt class="descname">jidt_kraskov</tt><big>(</big><em>self</em>, <em>var1</em>, <em>var2</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_mi.html#jidt_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_mi.jidt_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mutual information with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Kraskov 1 estimator. References:</p>
<p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Physical review E, 69(6), 066138.</p>
<p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front. Robot. AI, 1(11).</p>
<p>This function is ment to be imported into the set_estimator module and used
as a method in the Estimator_mi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_mi</span></dt>
<dd>function is supposed to be used as part of the Estimator_mi class</dd>
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the first random variable, where dimensions are
realisations x variable dimension</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second random variable</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8217;ACT&#8217;, the autocorr. time of the target)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=1e-8)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;num_threads&#8217; - no. CPU threads used for estimation
(default=&#8217;USE_ALL&#8217;, this uses all available cores on the
machine!)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>mutual information</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI calculator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_mi.opencl_kraskov">
<tt class="descclassname">idtxl.estimators_mi.</tt><tt class="descname">opencl_kraskov</tt><big>(</big><em>self</em>, <em>var1</em>, <em>var2</em>, <em>n_chunks=1</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_mi.html#opencl_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_mi.opencl_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mutual information using an opencl Kraskov implementation.</p>
<p>Calculate the mutual information between two variables using an
opencl-based Kraskov type 1 estimator. Multiple MIs can be estimated in
parallel, where each instance is called a &#8216;chunk&#8217;. References:</p>
<p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Physical review E, 69(6), 066138.</p>
<p>This function is ment to be imported into the set_estimator module and used
as a method in the Estimator_mi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_mi</span></dt>
<dd>function is supposed to be used as part of the Estimator_mi class</dd>
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the first random variable, where dimensions are
realisations x variable dimension</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second random variable</dd>
<dt>n_chunks <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>number of data sets or chunks (default=1)</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8217;ACT&#8217;, the autocorr. time of the target)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=1e-8)</li>
<li>&#8216;gpuid&#8217; - ID of the GPU device to be used (default=0)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>conditional mutual information</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>The Theiler window ignores trial boundaries. The MI estimator does add
noise to the data as a default. To make analysis runs replicable set
noise_level to 0.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_pid">
<span id="idtxl-estimators-pid-module"></span><h2>idtxl.estimators_pid module<a class="headerlink" href="#module-idtxl.estimators_pid" title="Permalink to this headline">¶</a></h2>
<p>Partical information decomposition for discrete random variables.</p>
<p>This module provides an estimator for partial information decomposition
as proposed in</p>
<p>Bertschinger, Rauh, Olbrich, Jost, Ay; Quantifying Unique Information,
Entropy 2014, 16, 2161-2183; doi:10.3390/e16042161</p>
<dl class="function">
<dt id="idtxl.estimators_pid.pid">
<tt class="descclassname">idtxl.estimators_pid.</tt><tt class="descname">pid</tt><big>(</big><em>s1_o</em>, <em>s2_o</em>, <em>target_o</em>, <em>cfg</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_pid.html#pid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.pid" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition of discrete variables.</p>
<p>The pid estimator returns estimates of shared information, unique
information and synergistic information that two random variables X and
Y have about a third variable Z. The estimator finds these estimates by
permuting the initial joint probability distribution of X, Y, and Z to
find a permuted distribution Q that minimizes the unique information in
X about Z (as proposed by Bertschinger and colleagues). The unique in-
formation is defined as the conditional mutual information I(X;Z|Y).</p>
<p>The estimator iteratively permutes the joint probability distribution of
X, Y, and Z under the constraint that the marginal distributions (X, Z)
and (Y, Z) stay constant. This is done by swapping two realizations of X
which have the same corresponding value in Z, e.g.:</p>
<blockquote>
<div><p>X [1, 0, 1, 1, 0, 1, 0, 0, 1, 1]
Y [0, 0, 1, 1, 1, 0, 0, 0, 1, 1]
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
Z [1, 1, 0, 0, 0, 1, 1, 0, 1, 0]</p>
<p>Possible swaps: X[0] and X[1]; X[0] and X[4]; X[2] and X[8]; ...</p>
</div></blockquote>
<p>After each swap, I(X;Z|Y) is re-calculated under the new distribution;
if the CMI is lower than the current permutation is kept and the next
swap is tested. The iteration stops after the provided number of
iterations.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">import numpy as np
import pid</p>
<p>n = 5000
alph = 2
x = np.random.randint(0, alph, n)
y = np.random.randint(0, alph, n)
z = np.logical_xor(x, y).astype(int)
cfg = {</p>
<blockquote>
<div>&#8216;alphabetsize&#8217;: 2,
&#8216;jarpath&#8217;: &#8216;/home/user/infodynamics-dist-1.3/infodynamics.jar&#8217;,
&#8216;iterations&#8217;: 10000</div></blockquote>
<p class="last">}
[est, opt] = pid(x, y, z, cfg)</p>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>s1 (numpy array): 1D array containing realizations of a discrete</dt>
<dd>random variable (this is the source variable the algorithm
calculates the actual UI for)</dd>
<dt>s2 (numpy array): 1D array containing realizations of a discrete</dt>
<dd>random variable (the other source variable)</dd>
<dt>target (numpy array): 1D array containing realizations of a discrete</dt>
<dd>random variable</dd>
<dt>cfg (dict): dictionary with estimation parameters, must contain</dt>
<dd>values for &#8216;alphabetsize&#8217; (no. values in each variable s1, s2,
target), &#8216;jarpath&#8217; (string with path to JIDT jar file),
&#8216;iterations&#8217; (no. iterations of the estimator)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>est (dict): estimated decomposition, contains: MI/CMI values computed</dt>
<dd>from non-permuted distributions; PID estimates (shared,
synergistic, unique information); I(target;s1,s2) under permuted
distribution Q</dd>
<dt>opt (dict): additional information about iterative optimization,</dt>
<dd>contains: final permutation Q; cfg dictionary; array with
I(target:s1|s2) for each iteration; array with delta
I(target:s1|s2) for each iteration; I(target:s1,s2) for each
iteration</dd>
</dl>
</dd>
<dt>Note:   variables names joined by &#8220;_&#8221; enter a mutual information</dt>
<dd>computation together i.e. mi_va1_var2 &#8211;&gt; I(var1 : var2).
variables names joined directly form a new joint variable
mi_var1var2_var3 &#8211;&gt; I(var3:(var1,var2))</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_te">
<span id="idtxl-estimators-te-module"></span><h2>idtxl.estimators_te module<a class="headerlink" href="#module-idtxl.estimators_te" title="Permalink to this headline">¶</a></h2>
<p>Provide transfer entropy estimators for the Estimator_te class.</p>
<p>This module exports methods for transfer entropy (TE) estimation in the
Estimator_te class.</p>
<dl class="function">
<dt id="idtxl.estimators_te.is_parallel">
<tt class="descclassname">idtxl.estimators_te.</tt><tt class="descname">is_parallel</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_te.html#is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_te.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if estimator can estimate CMI for multiple chunks in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_te.jidt_discrete">
<tt class="descclassname">idtxl.estimators_te.</tt><tt class="descname">jidt_discrete</tt><big>(</big><em>self</em>, <em>source</em>, <em>target</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_te.html#jidt_discrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_te.jidt_discrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate TE with JIDT&#8217;s implementation for discrete variables.</p>
<p>Calculate the transfer entropy between two time series processes.
Call JIDT via jpype and use the discrete estimator. Transfer entropy is
defined as the conditional mutual information between the source&#8217;s past
state and the target&#8217;s current value, conditional on the target&#8217;s past.</p>
<p>References:</p>
<p>Schreiber, T. (2000). Measuring information transfer. Physical Review
Letters, 85(2), 461.</p>
<p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front. Robot. AI, 1(11).</p>
<p>This function is ment to be imported into the set_estimator module and used
as a method in the Estimator_te class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_te</span></dt>
<dd>function is supposed to be used as part of the Estimator_te class</dd>
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">numpy array (either of integers or doubles to be discretised)</span></dt>
<dd>time series realisations of the first random variable.
Can be multidimensional (i.e. multivariate) where dimensions of the
array are realisations x variable dimension</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">numpy array (either of integers or doubles to be discretised)</span></dt>
<dd>time series realisations of the second random variable.
Can be multidimensional (i.e. multivariate) where dimensions of the
array are realisations x variable dimension</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last">
<li><dl class="first docutils">
<dt>&#8216;num_discrete_bins&#8217; - number of discrete bins/levels or the base</dt>
<dd><p class="first last">of each dimension of the discrete variables (default=2 for
binary). If this is set, then parameters &#8216;alph_source&#8217;,
&#8216;alph_target&#8217; and &#8216;alphc&#8217; are all set to this value</p>
</dd>
</dl>
</li>
<li><p class="first">&#8216;alph_source&#8217; - number of discrete bins/levels for source
(default=2 for binary, or the value set for &#8216;num_discrete_bins&#8217;)</p>
</li>
<li><p class="first">&#8216;alph_target&#8217; - number of discrete bins/levels for target
(default=2 for binary, or the value set for &#8216;num_discrete_bins&#8217;)</p>
</li>
<li><p class="first">&#8216;discretise_method&#8217; - if and how to discretise incoming
continuous variables to discrete values.
&#8216;max_ent&#8217; means to use a maximum entropy binning
&#8216;equal&#8217; means to use equal size bins
&#8216;none&#8217; means variables are already discrete (default=&#8217;none&#8217;)</p>
</li>
<li><p class="first">&#8216;history_target&#8217; - number of samples in the target&#8217;s past to
consider (mandatory to provide)</p>
</li>
<li><p class="first">&#8216;history_source&#8217; - number of samples in the source&#8217;s past to
consider (default=same as the target history)</p>
</li>
<li><p class="first">&#8216;tau_source&#8217; - source&#8217;s embedding delay (default=1)</p>
</li>
<li><p class="first">&#8216;tau_target&#8217; - target&#8217;s embedding delay (default=1)</p>
</li>
<li><p class="first">&#8216;source_target_delay&#8217; - information transfer delay between source
and target (default=1)</p>
</li>
<li><p class="first">&#8216;debug&#8217; - set debug prints from the calculator on (default=False)</p>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>transfer entropy</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_te.jidt_kraskov">
<tt class="descclassname">idtxl.estimators_te.</tt><tt class="descname">jidt_kraskov</tt><big>(</big><em>self</em>, <em>source</em>, <em>target</em>, <em>opts</em><big>)</big><a class="reference internal" href="_modules/idtxl/estimators_te.html#jidt_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_te.jidt_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate transfer entropy with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT&#8217;s implementation of the Kraskov type 1 estimator. Transfer entropy is
defined as the conditional mutual information between the source&#8217;s past
state and the target&#8217;s current value, conditional on the target&#8217;s past.</p>
<p>Past states need to be defined in the opts dictionary, where a past state
is defined as a uniform embedding with parameters history and tau. The
history describes the number of samples taken from a variable&#8217;s past, tau
descrices the embedding delay, i.e., the spacing between every two samples
from the processes&#8217; past.</p>
<p>References:</p>
<p>Schreiber, T. (2000). Measuring information transfer. Physical Review
Letters, 85(2), 461.</p>
<p>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating mutual
information. Physical review E, 69(6), 066138.</p>
<p>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front. Robot. AI, 1(11).</p>
<p>This function is ment to be imported into the set_estimator module and used
as a method in the Estimator_cmi class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>self <span class="classifier-delimiter">:</span> <span class="classifier">instance of Estimator_cmi</span></dt>
<dd>function is supposed to be used as part of the Estimator_cmi class</dd>
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the source variable</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the target variable</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8217;ACT&#8217;, the autocorr. time of the target)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=1e-8)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;history_target&#8217; - number of samples in the target&#8217;s past to
consider (mandatory to provide)</li>
<li>&#8216;history_source&#8217; - number of samples in the source&#8217;s past to
consider (default=same as the target history)</li>
<li>&#8216;tau_source&#8217; - source&#8217;s embedding delay (default=1)</li>
<li>&#8216;tau_target&#8217; - target&#8217;s embedding delay (default=1)</li>
<li>&#8216;source_target_delay&#8217; - information transfer delay between source
and target (default=1)</li>
<li>&#8216;debug&#8217; - set debug prints from the calculator on (default=False)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first docutils">
<dt>float</dt>
<dd>transfer entropy from source to target</dd>
</dl>
<p>OR
numpy array of floats</p>
<blockquote class="last">
<div>local transfer entropy if local_values is set</div></blockquote>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI calculator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.ft2idtxl">
<span id="idtxl-ft2idtxl-module"></span><h2>idtxl.ft2idtxl module<a class="headerlink" href="#module-idtxl.ft2idtxl" title="Permalink to this headline">¶</a></h2>
<p>Provide functions to import FieldTrip mat-files (version&gt;7.3) to IDTxl.</p>
<p>Functions in this module read the (neurophysiological) data from a FieldTrip
file with the basic fields necessary for its analysis with the MATLAB toolbox
TRENTOOL (fields ). Creates a numpy array usable as input to IDTxl.</p>
<dl class="docutils">
<dt>Methods:</dt>
<dd>ft_trial_2_numpyarray(filename, FTstructname)</dd>
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>Created on Wed Mar 19 12:34:36 2014</p>
<p>&#64;author: Michael Wibral</p>
<dl class="function">
<dt id="idtxl.ft2idtxl.ft2idtxlconverter">
<tt class="descclassname">idtxl.ft2idtxl.</tt><tt class="descname">ft2idtxlconverter</tt><big>(</big><em>filename</em>, <em>FTstructname</em>, <em>fileversion</em><big>)</big><a class="reference internal" href="_modules/idtxl/ft2idtxl.html#ft2idtxlconverter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.ft2idtxl.ft2idtxlconverter" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert FieldTrip-style MATLAB-file into an IDTxl Data object.</p>
<p>Import a MATLAB structure with fields  &#8220;trial&#8221; (data), &#8220;label&#8221; (channel
labels), &#8220;time&#8221; (time stamps for data samples), and &#8220;fsample&#8221; (sampling
rate). This structure is the standard file format in the MATLAB toolbox
FieldTrip and commonly use to represent neurophysiological data (see also
<a class="reference external" href="http://www.fieldtriptoolbox.org/">http://www.fieldtriptoolbox.org/</a>). The functions reads a mat-file from
disc and returns a dictionary containing the information in the mat-file.
Data is represented as an IDTxl Data object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>full (matlab) filename on disk</dd>
<dt>FTstructname <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>variable name of the MATLAB structure that is in FieldTrip format
(autodetect will hopefully be possible later ...)</dd>
<dt>fileversion <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>version of the file, e.g. &#8220;v7.3&#8221; for MATLAB&#8217;s 7.3 format</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>&#8220;dataset&#8221;: instance of IDTxl Data object; &#8220;label&#8221;: list of channel
labels; &#8220;time&#8221;: numpy array of time stamps; &#8220;fsample&#8221;: sampling 
rate</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_exceptions">
<span id="idtxl-idtxl-exceptions-module"></span><h2>idtxl.idtxl_exceptions module<a class="headerlink" href="#module-idtxl.idtxl_exceptions" title="Permalink to this headline">¶</a></h2>
<dl class="exception">
<dt id="idtxl.idtxl_exceptions.IdtxlError">
<em class="property">exception </em><tt class="descclassname">idtxl.idtxl_exceptions.</tt><tt class="descname">IdtxlError</tt><big>(</big><em>value</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#IdtxlError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.IdtxlError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.Exception</span></tt></p>
</dd></dl>

<dl class="exception">
<dt id="idtxl.idtxl_exceptions.IdtxlParamError">
<em class="property">exception </em><tt class="descclassname">idtxl.idtxl_exceptions.</tt><tt class="descname">IdtxlParamError</tt><big>(</big><em>value</em>, <em>missing_param</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#IdtxlParamError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.IdtxlParamError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.Exception</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_exceptions.jpype_missing">
<tt class="descclassname">idtxl.idtxl_exceptions.</tt><tt class="descname">jpype_missing</tt><big>(</big><em>message</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#jpype_missing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.jpype_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Report a missing jpype installation.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_exceptions.n_replications_low">
<tt class="descclassname">idtxl.idtxl_exceptions.</tt><tt class="descname">n_replications_low</tt><big>(</big><em>message</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#n_replications_low"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.n_replications_low" title="Permalink to this definition">¶</a></dt>
<dd><p>Report if number of replications is too low for surrogate creation.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_exceptions.opencl_missing">
<tt class="descclassname">idtxl.idtxl_exceptions.</tt><tt class="descname">opencl_missing</tt><big>(</big><em>message</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#opencl_missing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.opencl_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Report a missing opencl installation.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_io">
<span id="idtxl-idtxl-io-module"></span><h2>idtxl.idtxl_io module<a class="headerlink" href="#module-idtxl.idtxl_io" title="Permalink to this headline">¶</a></h2>
<p>Provide load and save functionality for IDTxl results.</p>
<dl class="function">
<dt id="idtxl.idtxl_io.load">
<tt class="descclassname">idtxl.idtxl_io.</tt><tt class="descname">load</tt><big>(</big><em>file_path</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_io.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_io.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load IDTxl data from disk.</p>
<p>Load different data types to disk. Supported types are:</p>
<ul class="simple">
<li>dictionaries with results, e.g., from Multivariate_te</li>
<li>numpy array</li>
<li>instance of IDTXL Data object</li>
</ul>
<p>File extensions are</p>
<ul class="simple">
<li>.txt for dictionaries (JSON file)</li>
<li>.npy for numpy array</li>
<li>.npz for Data instances</li>
</ul>
<p>Note that while numpy arrays and Data instances are saved in binary for
performance, dictionaries are saved in the json format, which is human-
readable and also easily read into other programs (e.g., MATLAB:
<a class="reference external" href="http://undocumentedmatlab.com/blog/json-matlab-integration">http://undocumentedmatlab.com/blog/json-matlab-integration</a>).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>string with file name (including the path)</dd>
</dl>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_io.save">
<tt class="descclassname">idtxl.idtxl_io.</tt><tt class="descname">save</tt><big>(</big><em>dat</em>, <em>file_path</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_io.html#save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_io.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save IDTxl data to disk.</p>
<p>Save different data types to disk. Supported types are:</p>
<ul class="simple">
<li>dictionaries with results, e.g., from Multivariate_te</li>
<li>numpy array</li>
<li>instance of IDTXL Data object</li>
</ul>
<p>Note that while numpy arrays and Data instances are saved in binary for
performance, dictionaries are saved in the json format, which is human-
readable and also easily read into other programs (e.g., MATLAB:
<a class="reference external" href="http://undocumentedmatlab.com/blog/json-matlab-integration">http://undocumentedmatlab.com/blog/json-matlab-integration</a>).</p>
<p>File extensions are</p>
<ul class="simple">
<li>.txt for dictionaries (JSON file)</li>
<li>.npy for numpy array</li>
<li>.npz for Data instances</li>
</ul>
<p>If the extension is not provided in the file_path, the function will add it
depending on the type of the data to be written.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dat <span class="classifier-delimiter">:</span> <span class="classifier">dict | numpy array | Data object</span></dt>
<dd>data to be saved to disk</dd>
<dt>file_path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>string with file name (including the path)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_utils">
<span id="idtxl-idtxl-utils-module"></span><h2>idtxl.idtxl_utils module<a class="headerlink" href="#module-idtxl.idtxl_utils" title="Permalink to this headline">¶</a></h2>
<p>Provide IDTxl utility functions.</p>
<dl class="function">
<dt id="idtxl.idtxl_utils.argsort_descending">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">argsort_descending</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#argsort_descending"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.argsort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order and return sortind indices.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.autocorrelation">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">autocorrelation</tt><big>(</big><em>x</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#autocorrelation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate autocorrelation of a vector.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.combine_discrete_dimensions">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">combine_discrete_dimensions</tt><big>(</big><em>a</em>, <em>numBins</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#combine_discrete_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.combine_discrete_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine all dimensions for a discrete variable down into a single
dimensional value for each sample.
This is done basically by multiplying each dimension
by a different power of the base (numBins).
Adapted from infodynamics.utils.MatrixUtils.computeCombinedValues() from JIDT by J.Lizier</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be combined across all variable dimensions. Dimensions are
realisations (samples) x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins for each variable dimension</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>a univariate array &#8211; one entry now for each sample,
with all dimensions of the data now combined for that sample</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.discretise">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">discretise</tt><big>(</big><em>a</em>, <em>numBins</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data into discrete values (with 0 as lowest)
by evenly partitioning the range of the data, one dimension at a time.
Adapted from infodynamics.utils.MatrixUtils.discretise() from JIDT by J.Lizier</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be discretised. Dimensions are
realisations x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins to partition the data into</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>discretised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.discretise_max_ent">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">discretise_max_ent</tt><big>(</big><em>a</em>, <em>numBins</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise_max_ent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise_max_ent" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data into discrete values (with 0 as lowest)
by making a maximum entropy partitioning, one dimension at a time.
Adapted from infodynamics.utils.MatrixUtils.discretiseMaxEntropy() from JIDT by J.Lizier</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be discretised. Dimensions are
realisations x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins to partition the data into</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>discretised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.print_dict">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">print_dict</tt><big>(</big><em>d</em>, <em>indent=4</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#print_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.print_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Python&#8217;s pretty printer to print dictionaries to the console.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.remove_column">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">remove_column</tt><big>(</big><em>a</em>, <em>j</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a column from a numpy array.</p>
<p>This is faster than logical indexing (&#8216;25 times faster&#8217;), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2-dimensional numpy array</dd>
<dt>i <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>column index to be removed</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.remove_row">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">remove_row</tt><big>(</big><em>a</em>, <em>i</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_row"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a row from a numpy array.</p>
<p>This is faster than logical indexing (&#8216;25 times faster&#8217;), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2-dimensional numpy array</dd>
<dt>i <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>row index to be removed</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.sort_descending">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">sort_descending</tt><big>(</big><em>a</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#sort_descending"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.sort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.standardise">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">standardise</tt><big>(</big><em>a</em>, <em>dimension=0</em>, <em>df=1</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#standardise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.standardise" title="Permalink to this definition">¶</a></dt>
<dd><p>Z-standardise a numpy array along a given dimension.</p>
<p>Standardise array along the axis defined in dimension using the denominator
(N - df) for the calculation of the standard deviation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be standardised</dd>
<dt>dimension <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>dimension along which array should be standardised</dd>
<dt>df <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>degrees of freedom for the denominator of the standard derivation</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>standardised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.swap_chars">
<tt class="descclassname">idtxl.idtxl_utils.</tt><tt class="descname">swap_chars</tt><big>(</big><em>s</em>, <em>i_1</em>, <em>i_2</em><big>)</big><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#swap_chars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.swap_chars" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap to characters in a string.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">swap_chars</span><span class="p">(</span><span class="s">&#39;heLlotHere&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">&#39;heHlotLere&#39;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.matarray2idtxl">
<span id="idtxl-matarray2idtxl-module"></span><h2>idtxl.matarray2idtxl module<a class="headerlink" href="#module-idtxl.matarray2idtxl" title="Permalink to this headline">¶</a></h2>
<p>Import MATLAB arrays into IDTxl.</p>
<p>Module with functions to import matrices from matfiles (version&gt;7.3, hdf5)
to IDTxL.</p>
<p>Functions in this module read the (neurophysiological) data from a Fieldtrip
file with the basic fields necessary for the MATLAB version TRENTOOL and create
a numpy array usable as input to TXL.</p>
<dl class="docutils">
<dt>provides the functions:</dt>
<dd><dl class="first last docutils">
<dt>matarray2idtxlconverter(filename, arrayname, order) =     takes a filename,</dt>
<dd>the name of the array variable (arrayname) inside,
and the order of sensor axis,  time axisand (CHECK THIS!!)
repetition axis (as a list)</dd>
</dl>
</dd>
</dl>
<p>&#64;author: Michael Wibral</p>
<dl class="function">
<dt id="idtxl.matarray2idtxl.matarray2idtxl">
<tt class="descclassname">idtxl.matarray2idtxl.</tt><tt class="descname">matarray2idtxl</tt><big>(</big><em>filename</em>, <em>array_name</em>, <em>order_list</em><big>)</big><a class="reference internal" href="_modules/idtxl/matarray2idtxl.html#matarray2idtxl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.matarray2idtxl.matarray2idtxl" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.matarray2idtxl.reorder_array">
<tt class="descclassname">idtxl.matarray2idtxl.</tt><tt class="descname">reorder_array</tt><big>(</big><em>the_array</em>, <em>order_list</em><big>)</big><a class="reference internal" href="_modules/idtxl/matarray2idtxl.html#reorder_array"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.matarray2idtxl.reorder_array" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-idtxl.multivariate_te">
<span id="idtxl-multivariate-te-module"></span><h2>idtxl.multivariate_te module<a class="headerlink" href="#module-idtxl.multivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Estimate multivarate TE.</p>
<p>Created on Thu Mar 10 14:24:31 2016</p>
<p>Iterative greedy algorithm for multivariate network inference using transfer
entropy. For details see Lizier 2012 and Faes 2011.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.multivariate_te.Multivariate_te">
<em class="property">class </em><tt class="descclassname">idtxl.multivariate_te.</tt><tt class="descname">Multivariate_te</tt><big>(</big><em>max_lag_sources</em>, <em>min_lag_sources</em>, <em>max_lag_target</em>, <em>options</em>, <em>tau_sources=1</em>, <em>tau_target=1</em><big>)</big><a class="reference internal" href="_modules/idtxl/multivariate_te.html#Multivariate_te"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_te.Multivariate_te" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.Network_analysis" title="idtxl.network_analysis.Network_analysis"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.network_analysis.Network_analysis</span></tt></a></p>
<p>Set up a network analysis using multivariate transfer entropy.</p>
<p>Set parameters necessary for network inference using transfer entropy (TE).
To perform network inference call analyse_network() on an instance of the
data class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>max_lag_target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth for candidates in the target&#8217;s past
(default=same as max_lag_sources)</dd>
<dt>max_lag_sources <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth for candidates in the sources&#8217; past</dd>
<dt>min_lag_sources <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>minimum temporal search depth for candidates in the sources&#8217; past</dd>
<dt>tau_sources <span class="classifier-delimiter">:</span> <span class="classifier">int [optinal]</span></dt>
<dd>spacing between candidates in the sources&#8217; past (default=1)</dd>
<dt>tau_target <span class="classifier-delimiter">:</span> <span class="classifier">int [optinal]</span></dt>
<dd>spacing between candidates in the target&#8217;s past (default=1)</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimator use and statistics:</p>
<ul class="last simple">
<li>&#8216;n_perm_*&#8217; - number of permutations, where * can be &#8216;max_stat&#8217;,
&#8216;min_stat&#8217;, &#8216;omnibus&#8217;, and &#8216;max_seq&#8217; (default=500)</li>
<li>&#8216;alpha_*&#8217; - critical alpha level for statistical significance,
where * can be &#8216;max_stats&#8217;,  &#8216;min_stats&#8217;, &#8216;omnibus&#8217;, and
&#8216;max_seq&#8217; (default=0.05)</li>
<li>&#8216;cmi_calc_name&#8217; - estimator to be used for CMI calculation
(For estimator options see the respective documentation.)</li>
<li>&#8216;add_conditionals&#8217; - force the estimator to add these
conditionals when estimating TE; can either be a list of
variables, where each variable is described as (idx process, lag
wrt to current value) or can be a string: &#8216;faes&#8217; for Faes-Method</li>
</ul>
</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>samples in the full conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_sources <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>source samples in the conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_target <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>target samples in the conditional set, (idx process, idx sample)</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value in TE estimation, (idx process,
idx sample)</dd>
<dt>calculator_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>calculator used for TE estimation</dd>
<dt>max_lag_target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth for candidates in the target&#8217;s past
(default=same as max_lag_sources)</dd>
<dt>max_lag_sources <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth for candidates in the sources&#8217; past</dd>
<dt>min_lag_sources <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>minimum temporal search depth for candidates in the sources&#8217; past</dd>
<dt>tau_sources <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>spacing between candidates in the sources&#8217; past</dd>
<dt>tau_target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>spacing between candidates in the target&#8217;s past</dd>
<dt>pvalue_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>p-value of the omnibus test</dd>
<dt>pvalues_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>array of p-values for TE from individual sources to the target</dd>
<dt>te_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>joint TE from all sources to the target</dd>
<dt>te_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>raw TE values from individual sources to the target</dd>
<dt>sign_ominbus <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>statistical significance of the over-all TE</dd>
<dt>source_set <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list with indices of source processes</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>index of target process</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>dictionary with the analysis options</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.multivariate_te.Multivariate_te.analyse_network">
<tt class="descname">analyse_network</tt><big>(</big><em>data</em>, <em>targets='all'</em>, <em>sources='all'</em><big>)</big><a class="reference internal" href="_modules/idtxl/multivariate_te.html#Multivariate_te.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_te.Multivariate_te.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between all nodes in the network.</p>
<p>Estimate multivariate transfer entropy between provided sources and
each target. Custom source sets can be provided for each target, as
lists of lists of nodes.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_lag</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_lag</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">analysis_opts</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;cmi_calc_name&#39;</span><span class="p">:</span> <span class="s">&#39;jidt_kraskov&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">Multivariate_te</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">analysis_opts</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                   <span class="n">min_lag</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>For more details on the estimation of multivariate transfer entropy
see documentation of class method &#8216;analyse_single_target&#8217;.</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">list of int | &#8216;all&#8217; [optinal]</span></dt>
<dd>index of target processes (default=&#8217;all&#8217;)</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | list of list | &#8216;all&#8217; [optional]</span></dt>
<dd>indices of source processes for each target (default=&#8217;all&#8217;);
if &#8216;all&#8217;, all sources are tested for each target;
if list of int, sources specified in the list are tested for
each target;
if list of list, sources specified in each inner list are
tested for the corresponding target</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.multivariate_te.Multivariate_te.analyse_single_target">
<tt class="descname">analyse_single_target</tt><big>(</big><em>data</em>, <em>target</em>, <em>sources='all'</em><big>)</big><a class="reference internal" href="_modules/idtxl/multivariate_te.html#Multivariate_te.analyse_single_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_te.Multivariate_te.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between sources and a target.</p>
<p>Find multivariate transfer entropy between all source processes and the
target process. Uses multivariate, non-uniform embedding found through
information maximisation (see Faes, ???, and Lizier, 2012). This is
done in four steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li>find all relevant samples in the target processes&#8217; own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</li>
<li>find all relevant samples in the source processes&#8217; pasts (again
by finding all candidates with significant CMI)</li>
<li>prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</li>
<li>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual samples in the set)</li>
</ol>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of target process</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int, int, or &#8216;all&#8217; [optinal]</span></dt>
<dd>single index or list of indices of source processes, if &#8216;all&#8217;,
all possible sources for the given target are tested
(default=&#8217;all&#8217;)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results consisting of conditional sets (full, from sources,
from target), results for omnibus test (joint influence of
source cands.), pvalues for each significant source candidate</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="idtxl-neighbour-search-cuda-module">
<h2>idtxl.neighbour_search_cuda module<a class="headerlink" href="#idtxl-neighbour-search-cuda-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-idtxl.neighbour_search_opencl">
<span id="idtxl-neighbour-search-opencl-module"></span><h2>idtxl.neighbour_search_opencl module<a class="headerlink" href="#module-idtxl.neighbour_search_opencl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="idtxl.neighbour_search_opencl.clFindKnn">
<tt class="descclassname">idtxl.neighbour_search_opencl.</tt><tt class="descname">clFindKnn</tt><big>(</big><em>h_bf_indexes</em>, <em>h_bf_distances</em>, <em>h_pointset</em>, <em>h_query</em>, <em>kth</em>, <em>thelier</em>, <em>nchunks</em>, <em>pointdim</em>, <em>signallength</em>, <em>gpuid</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl.html#clFindKnn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl.clFindKnn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl.clFindRSAll">
<tt class="descclassname">idtxl.neighbour_search_opencl.</tt><tt class="descname">clFindRSAll</tt><big>(</big><em>h_bf_npointsrange</em>, <em>h_pointset</em>, <em>h_query</em>, <em>h_vecradius</em>, <em>thelier</em>, <em>nchunks</em>, <em>pointdim</em>, <em>signallength</em>, <em>gpuid</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl.html#clFindRSAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl.clFindRSAll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl.find_nonempty">
<tt class="descclassname">idtxl.neighbour_search_opencl.</tt><tt class="descname">find_nonempty</tt><big>(</big><em>a_list</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl.html#find_nonempty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl.find_nonempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Find non-empty device in list.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl.knn_search">
<tt class="descclassname">idtxl.neighbour_search_opencl.</tt><tt class="descname">knn_search</tt><big>(</big><em>pointset</em>, <em>n_dim</em>, <em>knn_k</em>, <em>theiler_t</em>, <em>n_chunks=1</em>, <em>gpuid=0</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl.html#knn_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl.knn_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface with OpenCL knn search from Python/IDTxl.</p>
<p>Function checks input for correct dimensionality and transposes point sets
if necessary. Function also checks the maximum available memory on the GPU
device and splits chunks over multiple calls to the GPU (runs).</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl.range_search">
<tt class="descclassname">idtxl.neighbour_search_opencl.</tt><tt class="descname">range_search</tt><big>(</big><em>pointset</em>, <em>n_dim</em>, <em>radius</em>, <em>theiler_t</em>, <em>n_chunks=1</em>, <em>gpuid=0</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl.html#range_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl.range_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface with OpenCL range search from Python/IDTxl.</p>
<p>Function checks input for correct dimensionality and transposes point sets
if necessary. Function also checks the maximum available memory on the GPU
device and splits chunks over multiple calls to the GPU (runs).</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.neighbour_search_opencl_old">
<span id="idtxl-neighbour-search-opencl-old-module"></span><h2>idtxl.neighbour_search_opencl_old module<a class="headerlink" href="#module-idtxl.neighbour_search_opencl_old" title="Permalink to this headline">¶</a></h2>
<p>Provide neighbour searches using OpenCl GPU-code.</p>
<dl class="function">
<dt id="idtxl.neighbour_search_opencl_old.clFindKnn">
<tt class="descclassname">idtxl.neighbour_search_opencl_old.</tt><tt class="descname">clFindKnn</tt><big>(</big><em>h_bf_indexes</em>, <em>h_bf_distances</em>, <em>h_pointset</em>, <em>h_query</em>, <em>kth</em>, <em>thelier</em>, <em>nchunks</em>, <em>pointdim</em>, <em>signallength</em>, <em>gpuid</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl_old.html#clFindKnn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl_old.clFindKnn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl_old.clFindRSAll">
<tt class="descclassname">idtxl.neighbour_search_opencl_old.</tt><tt class="descname">clFindRSAll</tt><big>(</big><em>h_bf_npointsrange</em>, <em>h_pointset</em>, <em>h_query</em>, <em>h_vecradius</em>, <em>thelier</em>, <em>nchunks</em>, <em>pointdim</em>, <em>signallength</em>, <em>gpuid</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl_old.html#clFindRSAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl_old.clFindRSAll" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl_old.find_nonempty">
<tt class="descclassname">idtxl.neighbour_search_opencl_old.</tt><tt class="descname">find_nonempty</tt><big>(</big><em>a_list</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl_old.html#find_nonempty"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl_old.find_nonempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Find non-empty device in list.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl_old.knn_search">
<tt class="descclassname">idtxl.neighbour_search_opencl_old.</tt><tt class="descname">knn_search</tt><big>(</big><em>pointset</em>, <em>n_dim</em>, <em>knn_k</em>, <em>theiler_t</em>, <em>n_chunks=1</em>, <em>gpuid=0</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl_old.html#knn_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl_old.knn_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface with OpenCL knn search from Python/IDTxl.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.neighbour_search_opencl_old.range_search">
<tt class="descclassname">idtxl.neighbour_search_opencl_old.</tt><tt class="descname">range_search</tt><big>(</big><em>pointset</em>, <em>n_dim</em>, <em>radius</em>, <em>theiler_t</em>, <em>n_chunks=1</em>, <em>gpuid=0</em><big>)</big><a class="reference internal" href="_modules/idtxl/neighbour_search_opencl_old.html#range_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.neighbour_search_opencl_old.range_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface with OpenCL range search from Python/IDTxl.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.network_analysis">
<span id="idtxl-network-analysis-module"></span><h2>idtxl.network_analysis module<a class="headerlink" href="#module-idtxl.network_analysis" title="Permalink to this headline">¶</a></h2>
<p>Parent class for all network analyses.</p>
<p>Created on Mon Mar  7 18:13:27 2016</p>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.network_analysis.Network_analysis">
<em class="property">class </em><tt class="descclassname">idtxl.network_analysis.</tt><tt class="descname">Network_analysis</tt><a class="reference internal" href="_modules/idtxl/network_analysis.html#Network_analysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_analysis.Network_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Provide an analysis setup for multivariate network inference.</p>
<p>Hold variables that are relevant for multivariate network inference.
The class holds</p>
<ol class="arabic simple">
<li>analysis parameters</li>
<li>&#8216;analysis pattern&#8217;, i.e., indices of random variables used for
network inference (e.g. current value and conditional in transfer
entropy estimation)</li>
<li>temporary data for analysis, i.e., realisations of the variables</li>
</ol>
<p>The class provides routines to check user input and set defaults. The
&#8216;analysis pattern&#8217; is represented by tuples or list of tuples (process
index, sample index), where a tuple indicates where to find realisations in
the data.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>target process of analysis</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value</dd>
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of the full set of random variables to be conditioned on</dd>
<dt>selected_vars_target <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of the set of conditionals coming from the target process</dd>
<dt>selected_vars_sources <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of the set of conditionals coming from source processes</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="idtxl.network_analysis.Network_analysis.current_value">
<tt class="descname">current_value</tt><a class="reference internal" href="_modules/idtxl/network_analysis.html#Network_analysis.current_value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_analysis.Network_analysis.current_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

<dl class="attribute">
<dt id="idtxl.network_analysis.Network_analysis.selected_vars_full">
<tt class="descname">selected_vars_full</tt><a class="reference internal" href="_modules/idtxl/network_analysis.html#Network_analysis.selected_vars_full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_analysis.Network_analysis.selected_vars_full" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of the full conditional set.</p>
</dd></dl>

<dl class="attribute">
<dt id="idtxl.network_analysis.Network_analysis.selected_vars_sources">
<tt class="descname">selected_vars_sources</tt><a class="reference internal" href="_modules/idtxl/network_analysis.html#Network_analysis.selected_vars_sources"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_analysis.Network_analysis.selected_vars_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of source samples in the conditional set.</p>
</dd></dl>

<dl class="attribute">
<dt id="idtxl.network_analysis.Network_analysis.selected_vars_target">
<tt class="descname">selected_vars_target</tt><a class="reference internal" href="_modules/idtxl/network_analysis.html#Network_analysis.selected_vars_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_analysis.Network_analysis.selected_vars_target" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of target samples in the conditional set.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.network_comparison">
<span id="idtxl-network-comparison-module"></span><h2>idtxl.network_comparison module<a class="headerlink" href="#module-idtxl.network_comparison" title="Permalink to this headline">¶</a></h2>
<p>Perform inference statistics on groups of data.</p>
<dl class="class">
<dt id="idtxl.network_comparison.Compare_single_recording">
<em class="property">class </em><tt class="descclassname">idtxl.network_comparison.</tt><tt class="descname">Compare_single_recording</tt><big>(</big><em>options</em><big>)</big><a class="reference internal" href="_modules/idtxl/network_comparison.html#Compare_single_recording"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_comparison.Compare_single_recording" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_comparison.Network_comparison" title="idtxl.network_comparison.Network_comparison"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.network_comparison.Network_comparison</span></tt></a></p>
<p>Statisticall compare two networks from a single recording.</p>
<dl class="docutils">
<dt>Arguments:</dt>
<dd><dl class="first last docutils">
<dt>network_1 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>results from network inference</dd>
<dt>network_2 <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>results from network inference</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>options for statistical comparison of networks
&#8216;cmi_calc_name&#8217; - estimator to be used for CMI calculation
(For estimator options see the respective documentation.)
&#8216;n_perm_comp&#8217; - number of permutations (default=500)
&#8216;alpha_comp&#8217; - critical alpha level for statistical significance
(default=0.05)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array, bool</dt>
<dd>statistical significance of difference of each source</dd>
<dt>numpy array, float</dt>
<dd>the test&#8217;s p-values for each difference</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.network_comparison.Compare_single_recording.compare">
<tt class="descname">compare</tt><big>(</big><em>network_a</em>, <em>network_b</em>, <em>data_a</em>, <em>data_b</em><big>)</big><a class="reference internal" href="_modules/idtxl/network_comparison.html#Compare_single_recording.compare"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_comparison.Compare_single_recording.compare" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.network_comparison.Network_comparison">
<em class="property">class </em><tt class="descclassname">idtxl.network_comparison.</tt><tt class="descname">Network_comparison</tt><big>(</big><em>options</em><big>)</big><a class="reference internal" href="_modules/idtxl/network_comparison.html#Network_comparison"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_comparison.Network_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.pyinfo">
<span id="idtxl-pyinfo-module"></span><h2>idtxl.pyinfo module<a class="headerlink" href="#module-idtxl.pyinfo" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="idtxl.pyinfo.cmi_kraskov">
<tt class="descclassname">idtxl.pyinfo.</tt><tt class="descname">cmi_kraskov</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/idtxl/pyinfo.html#cmi_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.pyinfo.cmi_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the conditional mutual information using the Kraskov 
estimator.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.pyinfo.mi_kraskov">
<tt class="descclassname">idtxl.pyinfo.</tt><tt class="descname">mi_kraskov</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/idtxl/pyinfo.html#mi_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.pyinfo.mi_kraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the mutual information using the Kraskov estimator.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.pyinfo.te_kraskov">
<tt class="descclassname">idtxl.pyinfo.</tt><tt class="descname">te_kraskov</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/idtxl/pyinfo.html#te_kraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.pyinfo.te_kraskov" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-idtxl.set_estimator">
<span id="idtxl-set-estimator-module"></span><h2>idtxl.set_estimator module<a class="headerlink" href="#module-idtxl.set_estimator" title="Permalink to this headline">¶</a></h2>
<p>Manage different estimators for information theoretic measures.</p>
<dl class="class">
<dt id="idtxl.set_estimator.Estimator">
<em class="property">class </em><tt class="descclassname">idtxl.set_estimator.</tt><tt class="descname">Estimator</tt><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Set the estimator requested by the user.</p>
<p>Estimator object that provides functionality for the estimation of
different information theoretic measuers. Child classes add the requested
estimator dynamically as the class method &#8216;estimate&#8217; at runtime.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>estimator_name <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>name of the estimator currently set for estimation</dd>
<dt>is_parallel <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if the estimator handles multiple estimations in parallel</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.set_estimator.Estimator.add_estimator">
<tt class="descname">add_estimator</tt><big>(</big><em>func</em>, <em>is_parallel</em>, <em>name=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator.add_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator.add_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the estimator for the &#8216;estimate&#8217; method.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>func <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd>function to be set as &#8216;estimate&#8217; method</dd>
<dt>is_parallel <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>True if the estimator handles multiple estimations in parallel</dd>
<dt>name <span class="classifier-delimiter">:</span> <span class="classifier">str [optional]</span></dt>
<dd>name of the estimator set for the &#8216;estimate&#8217; method; if no name
is given, func.__name__ is used</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.set_estimator.Estimator.estimate">
<tt class="descname">estimate</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Stub for the estimator method.</p>
</dd></dl>

<dl class="method">
<dt id="idtxl.set_estimator.Estimator.estimate_mult">
<tt class="descname">estimate_mult</tt><big>(</big><em>n_chunks=1</em>, <em>options=None</em>, <em>re_use=None</em>, <em>**data</em><big>)</big><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator.estimate_mult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator.estimate_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate measure for multiple data sets (chunks).</p>
<p>Test if the estimator used provides parallel capabilities; if so,
estimate measure for multiple data sets (&#8216;chunks&#8217;) in parallel.
Otherwise, iterate over individual chunks.</p>
<p>The number of variables in data depends on the measure to be estimated,
e.g., 2 for mutual information and 3 for TE.</p>
<p>Each entry in data should be a numpy array with realisations, where the
first axis is assumed to represent realisations (over chunks), while
the second axis is the variable dimension.</p>
<p>Each numpy array with realisations can hold either the realisations for
multiple chunks or can hold the realisation for a single chunk, which
gets replicated for parallel estimation and gets re-used for iterative
estimation, in order to save memory. The variables for re-use are
provided in re-use as list of dictionary keys indicating entries in
data for re-use.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">self : instance of Estimator_cmi
n_chunks : int [optional]</p>
<blockquote>
<div>number of data chunks (default=1)</div></blockquote>
<dl class="last docutils">
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd>sets estimation parameters (default=None)</dd>
<dt>re_use <span class="classifier-delimiter">:</span> <span class="classifier">list of keys [optional}</span></dt>
<dd>realisatins to be re-used (default=None)</dd>
<dt>data: dict of numpy arrays</dt>
<dd>realisations of random random variables</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>numpy array of estimated values for each data set/chunk</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="idtxl.set_estimator.Estimator.estimator_name">
<tt class="descname">estimator_name</tt><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator.estimator_name"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator.estimator_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the estimator set for the &#8216;estimate&#8217; method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.set_estimator.Estimator_ais">
<em class="property">class </em><tt class="descclassname">idtxl.set_estimator.</tt><tt class="descname">Estimator_ais</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator_ais"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator_ais" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.set_estimator.Estimator" title="idtxl.set_estimator.Estimator"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.set_estimator.Estimator</span></tt></a></p>
<p>Set the requested transfer entropy estimator.</p>
</dd></dl>

<dl class="class">
<dt id="idtxl.set_estimator.Estimator_cmi">
<em class="property">class </em><tt class="descclassname">idtxl.set_estimator.</tt><tt class="descname">Estimator_cmi</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator_cmi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator_cmi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.set_estimator.Estimator" title="idtxl.set_estimator.Estimator"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.set_estimator.Estimator</span></tt></a></p>
<p>Set the requested conditional mutual information estimator.</p>
</dd></dl>

<dl class="class">
<dt id="idtxl.set_estimator.Estimator_mi">
<em class="property">class </em><tt class="descclassname">idtxl.set_estimator.</tt><tt class="descname">Estimator_mi</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator_mi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator_mi" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.set_estimator.Estimator" title="idtxl.set_estimator.Estimator"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.set_estimator.Estimator</span></tt></a></p>
<p>Set the requested mutual information estimator.</p>
</dd></dl>

<dl class="class">
<dt id="idtxl.set_estimator.Estimator_te">
<em class="property">class </em><tt class="descclassname">idtxl.set_estimator.</tt><tt class="descname">Estimator_te</tt><big>(</big><em>estimator_name</em><big>)</big><a class="reference internal" href="_modules/idtxl/set_estimator.html#Estimator_te"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.set_estimator.Estimator_te" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.set_estimator.Estimator" title="idtxl.set_estimator.Estimator"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.set_estimator.Estimator</span></tt></a></p>
<p>Set the requested transfer entropy estimator.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.single_process_storage">
<span id="idtxl-single-process-storage-module"></span><h2>idtxl.single_process_storage module<a class="headerlink" href="#module-idtxl.single_process_storage" title="Permalink to this headline">¶</a></h2>
<p>Analysis of AIS in a network of processes.</p>
<p>Analysis of active information storage (AIS) in individual processes of a
network. The algorithm uses non-uniform embedding as described in Faes ???.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.single_process_storage.Single_process_storage">
<em class="property">class </em><tt class="descclassname">idtxl.single_process_storage.</tt><tt class="descname">Single_process_storage</tt><big>(</big><em>max_lag</em>, <em>options</em>, <em>tau=1</em><big>)</big><a class="reference internal" href="_modules/idtxl/single_process_storage.html#Single_process_storage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.single_process_storage.Single_process_storage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.Network_analysis" title="idtxl.network_analysis.Network_analysis"><tt class="xref py py-class docutils literal"><span class="pre">idtxl.network_analysis.Network_analysis</span></tt></a></p>
<p>Set up analysis of storage in each process of the network.</p>
<p>Set parameters necessary for active information storage (AIS) in every
process of a network. To perform AIS estimation call analyse_network() on
the whole network or a set of nodes or call analyse_single_process() to
estimate AIS for a single process. See docstrings of the two functions
for more information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>max_lag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>spacing between samples analyzed for information contribution
(default=1)</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimator use and statistics:</p>
<ul class="last simple">
<li>&#8216;n_perm_*&#8217; - number of permutations, where * can be &#8216;max_stat&#8217;,
&#8216;min_stat&#8217;, &#8216;mi&#8217; (default=500)</li>
<li>&#8216;alpha_*&#8217; - critical alpha level for statistical significance,
where * can be &#8216;max_stat&#8217;, &#8216;min_stat&#8217;, &#8216;mi&#8217; (default=0.05)</li>
<li>&#8216;cmi_calc_name&#8217; - estimator to be used for CMI calculation. Note
that this estimator is also used to estimate MI later on.
(For estimator options see the respective documentation.)</li>
<li>&#8216;add_conditionals&#8217; - force the estimator to add these
conditionals when estimating AIS; can be a list of
variables, where each variable is described as (idx process, lag
wrt to current value)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>samples in the past state, (idx process, idx sample)</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value in AIS estimation, (idx process,
idx sample)</dd>
<dt>calculator_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>calculator used for CMI/MI estimation</dd>
<dt>max_lag <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>maximum temporal search depth for candidates in the processes&#8217; past
(default=same as max_lag_sources)</dd>
<dt>tau <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>spacing between samples analyzed for information contribution</dd>
<dt>ais <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>raw AIS value</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>true if AIS is significant</dd>
<dt>pvalue: float</dt>
<dd>p-value of AIS</dd>
<dt>process_set <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list with indices of analyzed processes</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.single_process_storage.Single_process_storage.analyse_network">
<tt class="descname">analyse_network</tt><big>(</big><em>data</em>, <em>processes='all'</em><big>)</big><a class="reference internal" href="_modules/idtxl/single_process_storage.html#Single_process_storage.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.single_process_storage.Single_process_storage.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for multiple network processes.</p>
<p>Estimate active information storage for all or a subset of processes in
the network.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_lag</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">analysis_opts</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;cmi_calc_name&#39;</span><span class="p">:</span> <span class="s">&#39;jidt_kraskov&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">Single_process_storage</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span>
<span class="go">                                              analysis_opts,</span>
<span class="go">                                              tau=1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">processes</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>For more details on the estimation of active information storage
see documentation of class method &#8216;analyse_single_process&#8217;.</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">list of int | &#8216;all&#8217;</span></dt>
<dd>index of processes (default=&#8217;all&#8217;);
if &#8216;all&#8217;, AIS is estimated for all processes;
if list of int, AIS is estimated for processes specified in the
list.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.single_process_storage.Single_process_storage.analyse_single_process">
<tt class="descname">analyse_single_process</tt><big>(</big><em>data</em>, <em>process</em><big>)</big><a class="reference internal" href="_modules/idtxl/single_process_storage.html#Single_process_storage.analyse_single_process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.single_process_storage.Single_process_storage.analyse_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for a single process.</p>
<p>Estimate active information storage for one process in the network.
Uses non-uniform embedding found through information maximisation (see
Faes, 2011, and Lizier, ???). This is
done in three steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li>find all relevant samples in the processes&#8217; own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</li>
</ol>
<ol class="arabic simple" start="3">
<li>prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</li>
<li>calculate AIS using the final set of candidates as the past state
(calculate MI between samples in the past and the current value);
test for statistical significance using a permutation test</li>
</ol>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of process</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results consisting of conditional sets (full, from sources,
from target), results for omnibus test (joint influence of
source cands.), pvalues for each significant source candidate</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.stats">
<span id="idtxl-stats-module"></span><h2>idtxl.stats module<a class="headerlink" href="#module-idtxl.stats" title="Permalink to this headline">¶</a></h2>
<p>Provide statistics functions.</p>
<p>Created on Mon Mar  7 18:13:27 2016</p>
<p>&#64;author: patricia</p>
<dl class="function">
<dt id="idtxl.stats.max_statistic">
<tt class="descclassname">idtxl.stats.</tt><tt class="descname">max_statistic</tt><big>(</big><em>analysis_setup</em>, <em>data</em>, <em>candidate_set</em>, <em>te_max_candidate</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.max_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform maximum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the maximum
values obtained from surrogates of all remanining candidates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Multivariate_te instance</span></dt>
<dd>information on the current analysis</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>candidate_set <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>list of indices of remaning candidates</dd>
<dt>te_max_candidate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transfer entropy value to be tested</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing, can contain:</p>
<ul class="last simple">
<li>&#8216;n_perm_max_stat&#8217; - number of permutations (default=500)</li>
<li>&#8216;alpha_max_stat&#8217; - critical alpha level (default=0.05)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test&#8217;s p-value</dd>
<dt>numpy array</dt>
<dd>surrogate table</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.max_statistic_sequential">
<tt class="descclassname">idtxl.stats.</tt><tt class="descname">max_statistic_sequential</tt><big>(</big><em>analysis_setup</em>, <em>data</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.max_statistic_sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test if sorted transfer entropy (TE) values are significantly bigger than
their respective counterpart obtained from surrogates of all remanining
candidates: test if the biggest TE is bigger than the distribution
of biggest TE surrogate values; test if the 2nd biggest TE is bigger than
the distribution of 2nd biggest surrogate TE values; ...
Stop comparison if a TE value is non significant, all smaller values are
considered non-significant as well.</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Multivariate_te instance</span></dt>
<dd>information on the current analysis</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing, can contain:</p>
<ul class="last simple">
<li>&#8216;n_perm_max_seq&#8217; - number of permutations
(default=&#8217;n_perm_min_stat&#8217;<a href="#id1"><span class="problematic" id="id2">|</span></a>500)</li>
<li>&#8216;alpha_max_seq&#8217; - critical alpha level (default=0.05)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array, bool</dt>
<dd>statistical significance of each source</dd>
<dt>numpy array, float</dt>
<dd>the test&#8217;s p-values for each source</dd>
<dt>numpy array, float</dt>
<dd>TE values for individual sources</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.mi_against_surrogates">
<tt class="descclassname">idtxl.stats.</tt><tt class="descname">mi_against_surrogates</tt><big>(</big><em>analysis_setup</em>, <em>data</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/stats.html#mi_against_surrogates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.mi_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test estimaed mutual information for significance against surrogate data.</p>
<p>Shuffle realisations of the current value (point to be predicted) and re-
calculate mutual information (MI) for shuffled data. The actual estimated
MI is then compared against this distribution of MI values from surrogate
data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Multivariate_te instance</span></dt>
<dd>information on the current analysis</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing, can contain:</p>
<ul class="last simple">
<li>&#8216;n_perm_mi&#8217; - number of permutations (default=500)</li>
<li>&#8216;alpha_mi&#8217; - critical alpha level (default=0.05)</li>
<li>&#8216;tail_mi&#8217; - tail for testing, can be &#8216;one&#8217; or &#8216;two&#8217;
(default=&#8217;one&#8217;)</li>
<li>&#8216;perm_range&#8217; - permutation range if permutation over samples is
used to create surrogates (default=&#8217;max&#8217;)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>estimated MI value</dd>
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>p_value for estimated MI value</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.min_statistic">
<tt class="descclassname">idtxl.stats.</tt><tt class="descname">min_statistic</tt><big>(</big><em>analysis_setup</em>, <em>data</em>, <em>candidate_set</em>, <em>te_min_candidate</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/stats.html#min_statistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.min_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform minimum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the minimum
values obtained from surrogates of all remanining candidates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Multivariate_te instance</span></dt>
<dd>information on the current analysis</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>candidate_set <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>list of indices of remaning candidates</dd>
<dt>te_min_candidate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transfer entropy value to be tested</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing, can contain:</p>
<ul class="last simple">
<li>&#8216;n_perm_min_stat&#8217; - number of permutations (default=500)</li>
<li>&#8216;alpha_min_stat&#8217; - critical alpha level (default=0.05)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test&#8217;s p-value</dd>
<dt>numpy array</dt>
<dd>surrogate table</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.network_fdr">
<tt class="descclassname">idtxl.stats.</tt><tt class="descname">network_fdr</tt><big>(</big><em>results</em>, <em>alpha=0.05</em>, <em>correct_by_target=True</em><big>)</big><a class="reference internal" href="_modules/idtxl/stats.html#network_fdr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.network_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform FDR-correction on results of network inference.</p>
<p>Perform correction of the false discovery rate (FDR) after network
analysis. FDR correction can either be applied at the target level
(by correcting omnibus p-values) or at the single-link level (by correcting
p-values of individual links between single samples and the target).
Reference for FDR correction:</p>
<p>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>results <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>network inference results where each dict entry represents results
for one target node</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">float [optional]</span></dt>
<dd>critical alpha value for statistical significance (default=0.05)</dd>
<dt>correct_by_target <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if true p-values are corrected on the target level and on the
single-link level otherwise (default=True)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>input results structure pruned of non-significant links.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.omnibus_test">
<tt class="descclassname">idtxl.stats.</tt><tt class="descname">omnibus_test</tt><big>(</big><em>analysis_setup</em>, <em>data</em>, <em>opts=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/stats.html#omnibus_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.omnibus_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an omnibus test on identified conditional variables.</p>
<p>Test the joint information transfer from all identified sources to the
current value conditional on candidates in the target&#8217;s past. To test for
significance, this is repeated for shuffled realisations of the sources.
The distribution of values from shuffled data is then used as test
distribution.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Multivariate_te instance</span></dt>
<dd>information on the current analysis</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>opts <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing, can contain</p>
<ul class="last simple">
<li>&#8216;n_perm_omnibus&#8217; - number of permutations (default=500)</li>
<li>&#8216;alpha_omnibus&#8217; - critical alpha level (default=0.05)</li>
<li>&#8216;perm_range&#8217; - permutation range if permutation over samples is
used to create surrogates (default=&#8217;max&#8217;)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test&#8217;s p-value</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.surrogates">
<span id="idtxl-surrogates-module"></span><h2>idtxl.surrogates module<a class="headerlink" href="#module-idtxl.surrogates" title="Permalink to this headline">¶</a></h2>
<p>Create surrogate data.</p>
<p>Created on Tue Apr  5 16:40:40 2016</p>
<p>&#64;author: patricia</p>
<dl class="function">
<dt id="idtxl.surrogates.create_surrogates">
<tt class="descclassname">idtxl.surrogates.</tt><tt class="descname">create_surrogates</tt><big>(</big><em>realisations</em>, <em>replication_idx</em>, <em>n_perm</em>, <em>options=None</em><big>)</big><a class="reference internal" href="_modules/idtxl/surrogates.html#create_surrogates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.surrogates.create_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Create appropriate surrogate data from realisations.</p>
<p>Create surrogates by either permuting replications or samples in time,
depending on the data structure. The function checks if the data contain
enough replications to generate an appropriate amount of surrogate data
given the requested number of permutations (e.g., to create 500 meaningful
permutaions, we need at least 6 replications, because we can obtain
6! = 720 permutations over replications). If data are not sufficient,
surrogates are created by permuting data over time if the number of
replications is not sufficient or permutation over time was explicitely
requested in the options.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>realisations <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be permuted, where dimensions are
realisation idx x variable</dd>
<dt>replication_idx <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>each realisation&#8217;s replication index, has the same dimension as
realisation.shape[0]</dd>
<dt>n_perm <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>desired number of permutations the test for which surrogates are
used</dd>
<dt>options <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">options for surrogate creation, can contain:</p>
<ul class="simple">
<li>&#8216;perm_type&#8217; - &#8216;permute_replications&#8217; for permutation of</li>
</ul>
<p class="last">replications or &#8216;permute_samples&#8217; for permutation of samples
- &#8216;shuffle_samples&#8217; - if permutation type is &#8216;permute_samples&#8217;
this defines the method used for permuting data over time, can be
&#8216;random&#8217; (swaps samples at random), &#8216;blocks&#8217; (swaps blocks of
samples), &#8216;local&#8217; (swaps samples within a given range), or
&#8216;circular&#8217; (circular shift with given maximum)
- depending on the shuffling method, further options may be
defined, see help for function &#8216;permute_over_time()&#8217; in this module</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.surrogates.permute_over_replications">
<tt class="descclassname">idtxl.surrogates.</tt><tt class="descname">permute_over_replications</tt><big>(</big><em>realisations</em>, <em>replication_idx</em><big>)</big><a class="reference internal" href="_modules/idtxl/surrogates.html#permute_over_replications"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.surrogates.permute_over_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute replications while keeping temporal structure intact.</p>
<p>Permute whole replications while keeping the temporal order of samples
within single replications intact.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>realisations <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>shape[0] realisations of shape[1] variables</dd>
<dt>replication_idx <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>index of replication a realisation came from</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>permuted realisations</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.surrogates.permute_over_time">
<tt class="descclassname">idtxl.surrogates.</tt><tt class="descname">permute_over_time</tt><big>(</big><em>realisations</em>, <em>replication_idx</em>, <em>perm_type</em>, <em>*kwargs</em><big>)</big><a class="reference internal" href="_modules/idtxl/surrogates.html#permute_over_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.surrogates.permute_over_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Permute realisations in time within each replication.</p>
<p>Permute realisations in time but within each replication. This is the
fall-back option if the number of replications is too small to allow a
sufficient number of permutations for the generation of surrogate data. If
no permutation type is given, samples are randomly permuted over the
whole replication, i.e., over all time indices in the replication.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>realisations <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>shape[0] realisations of shape[1] variables</dd>
<dt>replication_idx <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>index of replication a realisation came from</dd>
<dt>perm_type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>type of permutation, can be &#8216;random&#8217; (swaps samples at random),
&#8216;blocks&#8217; (swaps blocks of samples), &#8216;local&#8217; (swaps samples within
a given range), or &#8216;circular&#8217; (shifts time series by a random
number of samples)</dd>
<dt><a href="#id3"><span class="problematic" id="id4">*</span></a>kwargs</dt>
<dd><p class="first">Arbitrary keyword arguments depending on the perm_type:</p>
<ul class="simple">
<li>if perm_type = &#8216;blocks&#8217;: &#8216;block_size&#8217; in samples, &#8216;swap_range&#8217; in</li>
</ul>
<p class="last">blocks (default=max)
- if perm_type = &#8216;local&#8217;: &#8216;perm_range&#8217; in samples, range over which
realisations are permuted (default=max)
- if perm_type = &#8216;circular&#8217;: &#8216;max_shift&#8217; in samples, the maximum
number of samples for shifting (default=max)</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>realisations permuted over time</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.visualise_graph">
<span id="idtxl-visualise-graph-module"></span><h2>idtxl.visualise_graph module<a class="headerlink" href="#module-idtxl.visualise_graph" title="Permalink to this headline">¶</a></h2>
<p>Export and plot results as networkx objects.</p>
<dl class="function">
<dt id="idtxl.visualise_graph.generate_network_graph">
<tt class="descclassname">idtxl.visualise_graph.</tt><tt class="descname">generate_network_graph</tt><big>(</big><em>res</em><big>)</big><a class="reference internal" href="_modules/idtxl/visualise_graph.html#generate_network_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.generate_network_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate graph object for the full network.</p>
<p>Generate a graph object from the network of (multivariate)
interactions (e.g., multivariate TE), using the networkx
class for directed graphs (DiGraph).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_network()</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.generate_source_graph">
<tt class="descclassname">idtxl.visualise_graph.</tt><tt class="descname">generate_source_graph</tt><big>(</big><em>res</em>, <em>sign_sources=True</em><big>)</big><a class="reference internal" href="_modules/idtxl/visualise_graph.html#generate_source_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.generate_source_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate graph object for a target process and single variables.</p>
<p>Generate a graph object from the network of (multivariate)
interactions (e.g., multivariate TE) between single samples and
a target sample (current value), using the networkx class for
directed graphs (DiGraph).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_single_target()</dd>
<dt>sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>add only sources significant information contribution
(default=True)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.plot_mute_graph">
<tt class="descclassname">idtxl.visualise_graph.</tt><tt class="descname">plot_mute_graph</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_mute_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_mute_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot MuTE example network.</p>
<p>Network of 5 AR-processes, which is used as an example the paper
on the MuTE toolbox (Montalto, PLOS ONE, 2014, eq. 14). The
network consists of five autoregressive (AR) processes with model
orders 2 and les and the following (non-linear) couplings:</p>
<blockquote>
<div>0 -&gt; 1, u = 2
0 -&gt; 2, u = 3
0 -&gt; 3, u = 2 (non-linear)
3 -&gt; 4, u = 1
4 -&gt; 3, u = 1</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.plot_network">
<tt class="descclassname">idtxl.visualise_graph.</tt><tt class="descname">plot_network</tt><big>(</big><em>res</em><big>)</big><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of multivariate TE between processes.</p>
<p>Plot graph of the network of (multivariate) interactions between
processes (e.g., multivariate TE). The function uses  the
networkx class for directed graphs (DiGraph) internally.
Plots a network and adjacency matrix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_network()</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.plot_selected_vars">
<tt class="descclassname">idtxl.visualise_graph.</tt><tt class="descname">plot_selected_vars</tt><big>(</big><em>res</em>, <em>sign_sources=True</em><big>)</big><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_selected_vars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_selected_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of a target process and single variables.</p>
<p>Plot graph of the network of (multivariate) interactions between
source variables and the current value. The function uses the
networkx class for directed graphs (DiGraph) internally.
Plots a network and reduced adjacency matrix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_single_target()</dd>
<dt>sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>add only sources significant information contribution
(default=True)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-idtxl" title="Permalink to this headline">¶</a></h2>
<p>IDTxl: Information Dynamics Toolkit xl.</p>
<p>Package provides functionality for information dynamics analysis for arbitrary
data with an emphasis on the analysis of large data sets and the use of
multi-node computing clusters.</p>
</div>
</div>


                </div>
              </div>
            </div>
          </div>
        </div>
         
<div class="col-md-3 hidden-xs" id="sidebar-wrapper">
  <div class="sidebar hidden-xs" role="navigation" aria-label="main navigation">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">idtxl package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_te">idtxl.bivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.data">idtxl.data module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_ais">idtxl.estimators_ais module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_cmi">idtxl.estimators_cmi module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_fast_pid">idtxl.estimators_fast_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_fast_pid_ext_rep">idtxl.estimators_fast_pid_ext_rep module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_mi">idtxl.estimators_mi module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_pid">idtxl.estimators_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_te">idtxl.estimators_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.ft2idtxl">idtxl.ft2idtxl module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_exceptions">idtxl.idtxl_exceptions module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_io">idtxl.idtxl_io module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_utils">idtxl.idtxl_utils module</a></li>
<li><a class="reference internal" href="#module-idtxl.matarray2idtxl">idtxl.matarray2idtxl module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_te">idtxl.multivariate_te module</a></li>
<li><a class="reference internal" href="#idtxl-neighbour-search-cuda-module">idtxl.neighbour_search_cuda module</a></li>
<li><a class="reference internal" href="#module-idtxl.neighbour_search_opencl">idtxl.neighbour_search_opencl module</a></li>
<li><a class="reference internal" href="#module-idtxl.neighbour_search_opencl_old">idtxl.neighbour_search_opencl_old module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_analysis">idtxl.network_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_comparison">idtxl.network_comparison module</a></li>
<li><a class="reference internal" href="#module-idtxl.pyinfo">idtxl.pyinfo module</a></li>
<li><a class="reference internal" href="#module-idtxl.set_estimator">idtxl.set_estimator module</a></li>
<li><a class="reference internal" href="#module-idtxl.single_process_storage">idtxl.single_process_storage module</a></li>
<li><a class="reference internal" href="#module-idtxl.stats">idtxl.stats module</a></li>
<li><a class="reference internal" href="#module-idtxl.surrogates">idtxl.surrogates module</a></li>
<li><a class="reference internal" href="#module-idtxl.visualise_graph">idtxl.visualise_graph module</a></li>
<li><a class="reference internal" href="#module-idtxl">Module contents</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/idtxl.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" role="search">
  <h3>Quick search</h3>
  <form class="search form-inline" action="search.html" method="get">
      <div class="input-append input-group">
        <input type="text" class="search-query form-control" name="q" placeholder="Search...">
        <span class="input-group-btn">
        <input type="submit" class="btn" value="Go" />
        </span>
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div> 
        
      </div><!-- /row -->

      <!-- row -->
      <div class="row footer-relbar">
<div id="navbar-related" class=" related navbar navbar-default" role="navigation" aria-label="related navigation">
  <div class="navbar-inner">
    <ul class="nav navbar-nav ">
        <li><a href="index.html">IDTxl 0.1 documentation</a></li>
    </ul>
<ul class="nav navbar-nav pull-right hidden-xs hidden-sm">
      
        <li><a href="py-modindex.html" title="Python Module Index" >modules</a></li>
        <li><a href="genindex.html" title="General Index" >index</a></li>
        <li><a href="#">top</a></li> 
      
    </ul>
  </div>
</div>
      </div><!-- /row -->

      <!-- footer -->
      <footer role="contentinfo">
          &copy; Copyright 2016, Patricia Wollstadt, Michael Wibral, Joe T. Lizier, Finn Connor, Raul Vicente.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.2.2.
      </footer>
      <!-- /footer -->

    </div>
    <!-- /container -->

  </body>
</html>