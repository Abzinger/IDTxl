<!DOCTYPE html>




<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <title>idtxl package &mdash; IDTxl 0.1 documentation</title>
    <meta name="description" content="">
    <meta name="author" content="">

    

<link rel="stylesheet" href="_static/css/basicstrap-base.css" type="text/css" />
<link rel="stylesheet" id="current-theme" href="_static/css/bootstrap3/bootswatch-spacelab.css" type="text/css" />
<link rel="stylesheet" id="current-adjust-theme" href="_static/css/adjust_theme/bootswatch-spacelab.css" type="text/css" />

<link rel="stylesheet" href="_static/css/font-awesome.min.css">

<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 40px;
  }
</style>

<link rel="stylesheet" href="_static/css/basicstrap.css" type="text/css" />
<link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
            URL_ROOT:    './',
            VERSION:     '0.1',
            COLLAPSE_INDEX: false,
            FILE_SUFFIX: '.html',
            HAS_SOURCE:  true
  };
</script>
    <script type="text/javascript" src="_static/js/jquery.min.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/js/bootstrap3.min.js"></script>
<script type="text/javascript" src="_static/js/jquery.cookie.min.js"></script>
<script type="text/javascript" src="_static/js/basicstrap.js"></script>
<script type="text/javascript">
</script>
    <link rel="top" title="IDTxl 0.1 documentation" href="index.html" /> 
  </head>
  <body role="document">
    <div id="navbar-top" class="navbar navbar-fixed-top navbar-default" role="navigation" aria-label="top navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">IDTxl 0.1 documentation</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
              <li class="dropdown visible-xs">
                <a role="button" id="localToc" data-toggle="dropdown" data-target="#" href="#">Table Of Contents <b class="caret"></b></a>
                <ul class="dropdown-menu localtoc sp-localtoc" role="menu" aria-labelledby="localToc">
                <ul>
<li><a class="reference internal" href="#">idtxl package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-idtxl.active_information_storage">idtxl.active_information_storage module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_te">idtxl.bivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.data">idtxl.data module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimator">idtxl.estimator module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_jidt">idtxl.estimators_jidt module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_opencl">idtxl.estimators_opencl module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_pid">idtxl.estimators_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_exceptions">idtxl.idtxl_exceptions module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_import">idtxl.idtxl_import module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_io">idtxl.idtxl_io module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_utils">idtxl.idtxl_utils module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_spectral_te">idtxl.multivariate_spectral_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_te">idtxl.multivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_analysis">idtxl.network_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_comparison">idtxl.network_comparison module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_inference">idtxl.network_inference module</a></li>
<li><a class="reference internal" href="#module-idtxl.partial_information_decomposition">idtxl.partial_information_decomposition module</a></li>
<li><a class="reference internal" href="#module-idtxl.single_process_analysis">idtxl.single_process_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.stats">idtxl.stats module</a></li>
<li><a class="reference internal" href="#module-idtxl.synergy_tartu">idtxl.synergy_tartu module</a></li>
<li><a class="reference internal" href="#module-idtxl.visualise_graph">idtxl.visualise_graph module</a></li>
<li><a class="reference internal" href="#module-idtxl">Module contents</a></li>
</ul>
</li>
</ul>

                </ul>
              </li>

            
              <li><a href="py-modindex.html" title="Python Module Index" >modules </a></li>
              <li><a href="genindex.html" title="General Index" accesskey="I">index </a></li>
            
            <li class="visible-xs"><a href="_sources/idtxl.txt" rel="nofollow">Show Source</a></li>

            <li class="visible-xs">
                <form class="search form-search form-inline navbar-form navbar-right sp-searchbox" action="search.html" method="get">
                  <div class="input-append input-group">
                    <input type="text" class="search-query form-control" name="q" placeholder="Search...">
                    <span class="input-group-btn">
                    <input type="submit" class="btn" value="Go" />
                    </span>
                  </div>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </li>

            

          </ul>

        </div>
      </div>
    </div>
    

    <!-- container -->
    <div class="container">

      <!-- row -->
      <div class="row">
        
        

        <div class="col-md-9" id="content-wrapper">
          <div class="document" role="main">
            <div class="documentwrapper">
              <div class="bodywrapper">
                <div class="body">
                  
  <div class="section" id="idtxl-package">
<h1>idtxl package<a class="headerlink" href="#idtxl-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-idtxl.active_information_storage">
<span id="idtxl-active-information-storage-module"></span><h2>idtxl.active_information_storage module<a class="headerlink" href="#module-idtxl.active_information_storage" title="Permalink to this headline">¶</a></h2>
<p>Analysis of AIS in a network of processes.</p>
<p>Analysis of active information storage (AIS) in individual processes of a
network. The algorithm uses non-uniform embedding as described in Faes ???.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.active_information_storage.ActiveInformationStorage">
<em class="property">class </em><code class="descclassname">idtxl.active_information_storage.</code><code class="descname">ActiveInformationStorage</code><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Estimate active information storage in individual processes.</p>
<p>Estimate active information storage (AIS) in individual processes of the
network. To perform AIS estimation call analyse_network() on the whole
network or a set of nodes or call analyse_single_process() to estimate
AIS for a single process. See docstrings of the two functions for more
information.</p>
<p>References:</p>
<blockquote>
<div><ul class="simple">
<li>Lizier, J. T., Prokopenko, M., &amp; Zomaya, A. Y. (2012). Local measures
of information storage in complex distributed computation. Inform
Sci, 208, 39–54. <a class="reference external" href="http://doi.org/10.1016/j.ins.2012.04.016">http://doi.org/10.1016/j.ins.2012.04.016</a></li>
<li>Wibral, M., Lizier, J. T., Vögler, S., Priesemann, V., &amp; Galuske, R.
(2014). Local active information storage as a tool to understand
distributed neural information processing. Front Neuroinf, 8, 1.
<a class="reference external" href="http://doi.org/10.3389/fninf.2014.00001">http://doi.org/10.3389/fninf.2014.00001</a></li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>process_set <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>list with indices of analyzed processes</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>analysis settings</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value in AIS estimation, (idx process,
idx sample)</dd>
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>samples in the past state, (idx process, idx sample)</dd>
<dt>ais <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>raw AIS value</dd>
<dt>sign <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>true if AIS is significant</dd>
<dt>pvalue: float</dt>
<dd>p-value of AIS</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.active_information_storage.ActiveInformationStorage.analyse_network">
<code class="descname">analyse_network</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>processes='all'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for multiple network processes.</p>
<p>Estimate active information storage for all or a subset of processes in
the network.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>For a detailed description see the documentation of the
analyse_single_process() method of this class and the references.</dd>
</dl>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_lag</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span> <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">processes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">ActiveInformationStorage</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                       <span class="n">processes</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>parameters for estimation and statistical testing, see
documentation of analyse_single_process() for details</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">list of int | &#8216;all&#8217;</span></dt>
<dd>index of processes (default=&#8217;all&#8217;);
if &#8216;all&#8217;, AIS is estimated for all processes;
if list of int, AIS is estimated for processes specified in the
list.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results for each process, see documentation of
analyse_single_process()</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.active_information_storage.ActiveInformationStorage.analyse_single_process">
<code class="descname">analyse_single_process</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>process</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/active_information_storage.html#ActiveInformationStorage.analyse_single_process"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.active_information_storage.ActiveInformationStorage.analyse_single_process" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage for a single process.</p>
<p>Estimate active information storage for one process in the network.
Uses non-uniform embedding found through information maximisation. This
is done in three steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li>find all relevant samples in the processes&#8217; own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</li>
</ol>
<ol class="arabic simple" start="3">
<li>prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</li>
<li>calculate AIS using the final set of candidates as the past state
(calculate MI between samples in the past and the current value);
test for statistical significance using a permutation test</li>
</ol>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimator use and statistics:</p>
<ul class="last simple">
<li>&#8216;cmi_estimator&#8217; : str - estimator to be used for CMI and MI
calculation (for estimator settings see the documentation in
the estimators_* modules)</li>
<li>&#8216;max_lag&#8217; : int - maximum temporal search depth for
candidates in the processes&#8217; past in samples</li>
<li>&#8216;tau&#8217; : int [optional] - spacing between candidates in
the sources&#8217; past in samples (default=1)</li>
<li>&#8216;n_perm_*&#8217; : int [optional] - number of permutations, where *
can be &#8216;max_stat&#8217;, &#8216;min_stat&#8217;, &#8216;mi&#8217; (default=500)</li>
<li>&#8216;alpha_*&#8217; : float [optional] - critical alpha level for
statistical significance, where * can be &#8216;max_stat&#8217;,
&#8216;min_stat&#8217;, &#8216;mi&#8217; (default=0.05)</li>
<li>&#8216;add_conditionals&#8217; : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: &#8216;faes&#8217; for Faes-Method (see references)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - force surrogate
creation by shuffling realisations in time instead of
shuffling replications; see documentation of
Data.permute_samples() for further settings (default=False)</li>
<li>&#8216;verbose&#8217; : bool [optional] - toggle console output
(default=True)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of process</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results consisting of sets of selected variables as, the
current value for this analysis, results for omnibus test
(joint influence of all selected variables, omnibus TE,
p-value, and significance); NOTE that all variables are listed
as tuples (process, lag wrt. current value)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.bivariate_te">
<span id="idtxl-bivariate-te-module"></span><h2>idtxl.bivariate_te module<a class="headerlink" href="#module-idtxl.bivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Estimate bivariate transfer entropy.</p>
<p>Calculate bivariate transfer entropy (TE) using the maximum statistic.</p>
<p>Created on Wed Apr 06 17:58:31 2016</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.bivariate_te.BivariateTE">
<em class="property">class </em><code class="descclassname">idtxl.bivariate_te.</code><code class="descname">BivariateTE</code><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Perform network inference using bivariate transfer entropy.</p>
<p>Perform network inference using bivariate transfer entropy (TE). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate TE for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<blockquote>
<div><ul class="simple">
<li>Schreiber, T. (2000). Measuring Information Transfer. Phys Rev Lett,
85(2), 461–464. <a class="reference external" href="http://doi.org/10.1103/PhysRevLett.85.461">http://doi.org/10.1103/PhysRevLett.85.461</a></li>
<li>Vicente, R., Wibral, M., Lindner, M., &amp; Pipa, G. (2011). Transfer
entropy-a model-free measure of effective connectivity for the
neurosciences. J Comp Neurosci, 30(1), 45–67.
<a class="reference external" href="http://doi.org/10.1007/s10827-010-0262-3">http://doi.org/10.1007/s10827-010-0262-3</a></li>
<li>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></li>
<li>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>source_set <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>indices of source processes tested for their influence on the
target</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>index of target process</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>analysis settings</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value in TE estimation, (idx process,
idx sample)</dd>
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>samples in the full conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_sources <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>source samples in the conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_target <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>target samples in the conditional set, (idx process, idx sample)</dd>
<dt>pvalue_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>p-value of the omnibus test</dd>
<dt>pvalues_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>array of p-values for TE from individual sources to the target</dd>
<dt>te_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>joint TE from all sources to the target</dd>
<dt>te_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>raw TE values from individual sources to the target</dd>
<dt>sign_ominbus <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>statistical significance of the over-all TE</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.bivariate_te.BivariateTE.analyse_network">
<code class="descname">analyse_network</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>targets='all'</em>, <em>sources='all'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between all nodes in the network.</p>
<p>Estimate bivariate transfer entropy (TE) between all nodes in the
network or between selected sources and targets.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>For a detailed description see the documentation of the
analyse_single_target() method of this class and the references.</dd>
</dl>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_lag</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_lag</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">Bivariate_te</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">list of int | &#8216;all&#8217; [optional]</span></dt>
<dd>index of target processes (default=&#8217;all&#8217;)</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | list of list | &#8216;all&#8217;  [optional]</span></dt>
<dd>indices of source processes for each target (default=&#8217;all&#8217;);
if &#8216;all&#8217;, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results for each target, see documentation of
analyse_single_target()</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.bivariate_te.BivariateTE.analyse_single_target">
<code class="descname">analyse_single_target</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>target</em>, <em>sources='all'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/bivariate_te.html#BivariateTE.analyse_single_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.bivariate_te.BivariateTE.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find bivariate transfer entropy between sources and a target.</p>
<p>Find bivariate transfer entropy (TE) between all potential source
processes and the target process. Uses bivariate, non-uniform embedding
found through information maximisation (see Faes et al., 2011, Phys Rev
E 83, 051112 and Lizier &amp; Rubinov, 2012, Max Planck Institute:
Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a>). Bivariate
TE is calculated in four steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li>find all relevant samples in the target processes&#8217; own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</li>
<li>find all relevant samples in the source processes&#8217; pasts (again
by finding all candidates with significant CMI)</li>
<li>prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</li>
<li>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual samples in the set)</li>
</ol>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag&#39;</span><span class="p">:</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">Bivariate_te</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">dat</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimation and statistical testing:</p>
<ul class="last simple">
<li>&#8216;cmi_estimator&#8217; : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</li>
<li>&#8216;max_lag_sources&#8217; : int - maximum temporal search depth for
candidates in the sources&#8217; past in samples</li>
<li>&#8216;min_lag_sources&#8217; : int - minimum temporal search depth for
candidates in the sources&#8217; past in samples</li>
<li>&#8216;max_lag_target&#8217; : int [optional] - maximum temporal search
depth for candidates in the target&#8217;s past in samples
(default=same as max_lag_sources)</li>
<li>&#8216;tau_sources&#8217; : int [optional] - spacing between candidates in
the sources&#8217; past in samples (default=1)</li>
<li>&#8216;tau_target&#8217; : int [optional] - spacing between candidates in
the target&#8217;s past in samples (default=1)</li>
<li>&#8216;n_perm_*&#8217; : int - number of permutations, where * can be
&#8216;max_stat&#8217;, &#8216;min_stat&#8217;, &#8216;omnibus&#8217;, and &#8216;max_seq&#8217;
(default=500)</li>
<li>&#8216;alpha_*&#8217; : float - critical alpha level for statistical
significance, where * can be &#8216;max_stats&#8217;,  &#8216;min_stats&#8217;, and
&#8216;omnibus&#8217; (default=0.05)</li>
<li>&#8216;add_conditionals&#8217; : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: &#8216;faes&#8217; for Faes-Method (see references)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - force surrogate
creation by shuffling realisations in time instead of
shuffling replications; see documentation of
Data.permute_samples() for further settings (default=False)</li>
<li>&#8216;verbose&#8217; : bool [optional] - toggle console output
(default=True)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of target process</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | int | &#8216;all&#8217; [optional]</span></dt>
<dd>single index or list of indices of source processes
(default=&#8217;all&#8217;), if &#8216;all&#8217;, all network nodes excluding the
target node are considered as potential sources</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results consisting of sets of selected variables as (full set,
variables from the sources&#8217; past, variables from the target&#8217;s
past), pvalues and TE for each selected variable, the current
value for this analysis, results for omnibus test (joint
influence of all selected source variables on the target,
omnibus TE, p-value, and significance); NOTE that all variables
are listed as tuples (process, lag wrt. current value)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.data">
<span id="idtxl-data-module"></span><h2>idtxl.data module<a class="headerlink" href="#module-idtxl.data" title="Permalink to this headline">¶</a></h2>
<p>Provide data structures for IDTxl analysis.</p>
<p>Created on Mon Mar  7 18:13:27 2016</p>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.data.Data">
<em class="property">class </em><code class="descclassname">idtxl.data.</code><code class="descname">Data</code><span class="sig-paren">(</span><em>data=None</em>, <em>dim_order='psr'</em>, <em>normalise=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Store data for information dynamics estimation.</p>
<p>Data takes a 1- to 3-dimensional array representing realisations of random
variables in dimensions: processes, samples (over time), and replications.
If necessary, data reshapes provided realisations to fit the format
expected by IDTxl, which is a 3-dimensional array with axes representing
(process index, sample index, replication index). Indicate the actual order
of dimensions in the provided array in a three-character string, e.g. &#8216;spr&#8217;
for an array with realisations over (1) samples in time, (2) processes, (3)
replications.</p>
<dl class="docutils">
<dt>Examples:</dt>
<dd>d_mute = Data()              # initialise empty data object
d_mute.generate_mute_data()  # simulate data from MuTE paper
dat = np.arange(10000).reshape((2, 1000, 5))  # random data: 2 procs.,
d1 = Data(dat, dim_order=&#8217;psr&#8217;)               # 1000 samples, 5 repl.
dat = np.arange(3000).reshape((3, 1000))  # random data: 3 procs.,
d2 = Data(dat, dim_order=&#8217;ps&#8217;)            # 1000 samples
dat_new = np.arange(5000)
d2.set_data(dat_new, &#8216;s&#8217;)  # set new data for the existing object</dd>
<dt>Note:</dt>
<dd>Realisations are stored as attribute &#8216;data&#8217;. This can&#8217;t be set
directly, but only via the method &#8216;set_data&#8217;</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>1/2/3-dimensional array with raw data</dd>
<dt>dim_order <span class="classifier-delimiter">:</span> <span class="classifier">string [optional]</span></dt>
<dd>order of dimensions, accepts any combination of the characters
&#8216;p&#8217;, &#8216;s&#8217;, and &#8216;r&#8217; for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., &#8216;ps&#8217; for a
two-dimensional array of data from several processes over time
(default=&#8217;psr&#8217;)</dd>
<dt>normalise <span class="classifier-delimiter">:</span> <span class="classifier">bool [optional]</span></dt>
<dd>if True, data gets normalised per process (default=True)</dd>
</dl>
</dd>
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations, can only be set via &#8216;set_data&#8217; method</dd>
<dt>n_processes <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of processes</dd>
<dt>n_replications <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of replications</dd>
<dt>n_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples in time</dd>
<dt>normalise <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if true, all data gets z-standardised per process</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="idtxl.data.Data.data">
<code class="descname">data</code><a class="headerlink" href="#idtxl.data.Data.data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data array.</p>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.generate_mute_data">
<code class="descname">generate_mute_data</code><span class="sig-paren">(</span><em>n_samples=1000</em>, <em>n_replications=10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.generate_mute_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.generate_mute_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate example data for a 5-process network.</p>
<p>Generate example data and overwrite the instance&#8217;s current data. The
network is used as an example the paper on the MuTE toolbox (Montalto,
PLOS ONE, 2014, eq. 14). The network consists of five autoregressive
(AR) processes with model orders 2 and les and the following
(non-linear) couplings:</p>
<p>0 -&gt; 1, u = 2 (non-linear)
0 -&gt; 2, u = 3
0 -&gt; 3, u = 2 (non-linear)
3 -&gt; 4, u = 1
4 -&gt; 3, u = 1</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>n_samples <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of samples simulated for each process and replication</dd>
<dt>n_replications <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of replications</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.get_realisations">
<code class="descname">get_realisations</code><span class="sig-paren">(</span><em>current_value</em>, <em>idx_list</em>, <em>shuffle=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.get_realisations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.get_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations for a list of indices.</p>
<p>Return realisations for indices in list. Optionally, realisations can
be shuffled to create surrogate data for statistical testing. For
shuffling, data blocks are permuted over replications while their
temporal order stays intact within replications:</p>
<dl class="docutils">
<dt>orig:</dt>
<dd>repl. index:   1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6 ...
sample index:  1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 ...</dd>
<dt>shuffled:</dt>
<dd>repl. index:   3 3 3 3 1 1 1 1 4 4 4 4 6 6 6 6 2 2 2 2 5 5 5 5 ...
sample index:  1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 1 2 3 4 ...</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>idx_list: list of tuples</dt>
<dd>variable indices</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value in current analysis, has to have the
form (idx process, idx sample); if current_value == idx, all
samples for a process are returned</dd>
<dt>shuffle: bool</dt>
<dd>if true permute blocks of replications over trials</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>realisations with dimensions (no. samples * no.replications) x
number of indices</dd>
<dt>numpy array</dt>
<dd>replication index for each realisation with dimensions (no.
samples * no.replications) x number of indices</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.n_realisations">
<code class="descname">n_realisations</code><span class="sig-paren">(</span><em>current_value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples and replications.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple [optional]</span></dt>
<dd>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, we count
realisations from the k+1th sample because we loose the first k
samples to the embedding); if no current_value is provided, the
number of all samples is used</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.n_realisations_repl">
<code class="descname">n_realisations_repl</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_repl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_repl" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over replications.</p>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.n_realisations_samples">
<code class="descname">n_realisations_samples</code><span class="sig-paren">(</span><em>current_value=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.n_realisations_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.n_realisations_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of realisations over samples.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple [optional]</span></dt>
<dd>reference point for calculation of number of realisations
(e.g. when using an embedding of length k, the current value is
at sample k + 1; we thus count realisations from the k + 1st
sample because we loose the first k samples to the embedding)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.permute_replications">
<code class="descname">permute_replications</code><span class="sig-paren">(</span><em>current_value</em>, <em>idx_list</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_replications"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.permute_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted replications (time stays intact).</p>
<p>Create surrogate data by permuting realisations over replications while
keeping the temporal structure (order of samples) intact. Return
realisations for all indices in the list, where an index is expected to
have the form (process index, sample index). Realisations are permuted
block-wise by permuting the order of replications:</p>
<dl class="docutils">
<dt>original data:</dt>
<dd>rep.:   1 1 1 1  2 2 2 2  3 3 3 3  4 4 4 4  5 5 5 5  6 6 6 6 ...
sample: 1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4 ...</dd>
<dt>permuted data:</dt>
<dd>rep.:   3 3 3 3  1 1 1 1  4 4 4 4  6 6 6 6  2 2 2 2  5 5 5 5 ...
sample: 1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4  1 2 3 4 ...</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current_value in the data</dd>
<dt>idx_list <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of variables</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>permuted realisations with dimensions replications x number of
indices</dd>
<dt>numpy array</dt>
<dd>replication index for each realisation</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>TypeError if idx_realisations is not a list</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.permute_samples">
<code class="descname">permute_samples</code><span class="sig-paren">(</span><em>current_value</em>, <em>idx_list</em>, <em>perm_settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.permute_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.permute_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return realisations with permuted samples (repl. stays intact).</p>
<p>Create surrogate data by permuting realisations over samples (time)
while keeping the order of replications intact. Return realisations for
all indices in the list, where an index is expected to have the form
(process index, sample index). Realisations are permuted according to
the settings specified in perm_settings:</p>
<dl class="docutils">
<dt>original data:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3 ...
sample: 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8 ...</dd>
<dt>circular shift (default) by 2, 6, and 4 samples:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3  ...
sample: 7 8 1 2 3 4 5 6  3 4 5 6 7 8 1 2  5 6 7 8 1 2 3 4  ...</dd>
<dt>permute blocks of 3 samples:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3 ...
sample: 4 5 6 7 8 1 2 3  1 2 3 7 8 4 5 6  7 8 4 5 6 1 2 3 ...</dd>
<dt>permute data locally within a range of 4 samples:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3 ...
sample: 1 2 4 3 8 5 6 7  4 1 2 3 5 7 8 6  3 1 2 4 8 5 6 7 ...</dd>
<dt>random permutation:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3  ...
sample: 4 2 5 7 1 3 2 6  4 2 5 7 1 3 2 6  4 2 5 7 1 3 2 6  ...</dd>
</dl>
<p>Permuting samples is the fall-back option for surrogate creation if the
number of replications is too small to allow for a sufficient number of
permutations for the generation of surrogate data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current_value in the data</dd>
<dt>idx_list <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of variables</dd>
<dt>perm_settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">settings specifying the allowed permutations:</p>
<ul class="last">
<li><p class="first">perm_type : str
permutation type, can be</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;random&#8217;: swaps samples at random,</li>
<li>&#8216;circular&#8217;: shifts time series by a random
number of samples</li>
<li>&#8216;block&#8217;: swaps blocks of samples,</li>
<li>&#8216;local&#8217;: swaps samples within a given range, or</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">additional settings depending on the perm_type (n is the
number of samples):</p>
<blockquote>
<div><ul>
<li><p class="first">if perm_type == &#8216;circular&#8217;:
&#8216;max_shift&#8217;: int</p>
<blockquote>
<div><p>the maximum number of samples for shifting
(e.g., number of samples / 2)</p>
</div></blockquote>
</li>
<li><p class="first">if perm_type == &#8216;block&#8217;:
&#8216;block_size&#8217; : int</p>
<blockquote>
<div><p>no. samples per block (e.g., number of samples / 10)</p>
</div></blockquote>
<dl class="docutils">
<dt>&#8216;perm_range&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">range in which blocks can be swapped (e.g., number
of samples / block_size)</p>
</dd>
</dl>
</li>
<li><p class="first">if perm_type == &#8216;local&#8217;:
&#8216;perm_range&#8217; : int</p>
<blockquote>
<div><p>range in samples over which realisations can be
permuted (e.g., number of samples / 10)</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>permuted realisations with dimensions replications x number of
indices</dd>
<dt>numpy array</dt>
<dd>sample index for each realisation</dd>
</dl>
</dd>
<dt>Raises:</dt>
<dd>TypeError if idx_realisations is not a list</dd>
<dt>Note:</dt>
<dd>This permutation scheme is the fall-back option if the number of
replications is too small to allow a sufficient number of
permutations for the generation of surrogate data.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em>, <em>dim_order</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.set_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite data in an existing Data object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1- to 3-dimensional array of realisations</dd>
<dt>dim_order <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>order of dimensions, accepts any combination of the characters
&#8216;p&#8217;, &#8216;s&#8217;, and &#8216;r&#8217; for processes, samples, and replications;
must have the same length as number of dimensions in data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.slice_permute_replications">
<code class="descname">slice_permute_replications</code><span class="sig-paren">(</span><em>process</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.slice_permute_replications"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.slice_permute_replications" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data slice with permuted replications (time stays intact).</p>
<p>Create surrogate data by permuting realisations over replications while
keeping the temporal structure (order of samples) intact. Return
realisations for all indices in the list, where an index is expected to
have the form (process index, sample index). Realisations are permuted
block-wise by permuting the order of replications</p>
</dd></dl>

<dl class="method">
<dt id="idtxl.data.Data.slice_permute_samples">
<code class="descname">slice_permute_samples</code><span class="sig-paren">(</span><em>process</em>, <em>perm_settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/data.html#Data.slice_permute_samples"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.data.Data.slice_permute_samples" title="Permalink to this definition">¶</a></dt>
<dd><p>Return slice of data with permuted samples (repl. stays intact).</p>
<p>Create surrogate data by permuting data in a slice over samples (time)
while keeping the order of replications intact. Return slice for the
entry specified by &#8216;process&#8217;. Realisations are permuted according to
the settings specified in perm_settings:</p>
<dl class="docutils">
<dt>original data:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3 ...
sample: 1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8 ...</dd>
<dt>circular shift (default) by 2, 6, and 4 samples:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3  ...
sample: 7 8 1 2 3 4 5 6  3 4 5 6 7 8 1 2  5 6 7 8 1 2 3 4  ...</dd>
<dt>permute blocks of 3 samples:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3 ...
sample: 4 5 6 7 8 1 2 3  1 2 3 7 8 4 5 6  7 8 4 5 6 1 2 3 ...</dd>
<dt>permute data locally within a range of 4 samples:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3 ...
sample: 1 2 4 3 8 5 6 7  4 1 2 3 5 7 8 6  3 1 2 4 8 5 6 7 ...</dd>
<dt>random permutation:</dt>
<dd>rep.:   1 1 1 1 1 1 1 1  2 2 2 2 2 2 2 2  3 3 3 3 3 3 3 3  ...
sample: 4 2 5 7 1 3 2 6  7 5 3 4 2 1 8 5  1 2 4 3 6 8 7 5  ...</dd>
</dl>
<p>Permuting samples is the fall-back option for surrogate creation if the
number of replications is too small to allow for a sufficient number of
permutations for the generation of surrogate data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>process for which to return data slice</dd>
<dt>perm_settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">settings specifying the allowed permutations:</p>
<ul class="last">
<li><p class="first">perm_type : str
permutation type, can be</p>
<blockquote>
<div><ul class="simple">
<li>&#8216;circular&#8217;: shifts time series by a random
number of samples</li>
<li>&#8216;block&#8217;: swaps blocks of samples,</li>
<li>&#8216;local&#8217;: swaps samples within a given range, or</li>
<li>&#8216;random&#8217;: swaps samples at random,</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">additional settings depending on the perm_type (n is the
number of samples):</p>
<blockquote>
<div><ul>
<li><p class="first">if perm_type == &#8216;circular&#8217;:
&#8216;max_shift&#8217;: int</p>
<blockquote>
<div><p>the maximum number of samples for shifting
(default=n/2)</p>
</div></blockquote>
</li>
<li><p class="first">if perm_type == &#8216;block&#8217;:
&#8216;block_size&#8217; : int</p>
<blockquote>
<div><p>no. samples per block (default=n/10)</p>
</div></blockquote>
<dl class="docutils">
<dt>&#8216;perm_range&#8217; <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">range in which blocks can be swapped (default=max)</p>
</dd>
</dl>
</li>
<li><p class="first">if perm_type == &#8216;local&#8217;:
&#8216;perm_range&#8217; : int</p>
<blockquote>
<div><p>range in samples over which realisations can be
permuted (default=n/10)</p>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>data slice with data permuted over samples with dimensions
samples x number of replications</dd>
<dt>numpy array</dt>
<dd>index of permutet samples</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>This permutation scheme is the fall-back option if the number of
replications is too small to allow a sufficient number of
permutations for the generation of surrogate data.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.estimator">
<span id="idtxl-estimator-module"></span><h2>idtxl.estimator module<a class="headerlink" href="#module-idtxl.estimator" title="Permalink to this headline">¶</a></h2>
<p>Provide estimator base class for information theoretic measures.</p>
<dl class="class">
<dt id="idtxl.estimator.Estimator">
<em class="property">class </em><code class="descclassname">idtxl.estimator.</code><code class="descname">Estimator</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimator.html#Estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimator.Estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Abstract class for implementation of IDTxl estimators.</p>
<p>Abstract class for implementation of IDTxl estimators. Child classes
implement various estimators for information-theoretic measures, e.g.,
mutual information (MI), conditional mutual information (CMI),
active information storage (AIS), or transfer entropy (TE).</p>
<p>Estimator classes implement a method &#8216;estimate()&#8217; for the estimation from
single or multiple data sets in parallel. Whether &#8216;estimate()&#8217; provides
parallel computing capabilities is indicated by the &#8216;is_parallel()&#8217;
method. The &#8216;estimate_mult()&#8217; method of this abstract class provides a
common interface to parallel and serial methods (see docstring for
details).</p>
<p>The method &#8216;is_analytic_null_estimator()&#8217; indicates whether the implemented
estimator supports the generation of analytic surrogates (see docstring for
details).</p>
<dl class="method">
<dt id="idtxl.estimator.Estimator.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>**vars</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimator.html#Estimator.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimator.Estimator.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate measure for a single data set.</p>
<p>The number of variables in data depends on the measure to be estimated,
e.g., 2 for mutual information and 3 for a conditional mutual
information.</p>
<p>Each entry in data should be a numpy array with realisations, where the
first axis is assumed to represent realisations over samples and
replications, while the second axis represents the variable dimension
([(samples * replications) x variable dimension]).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">self : instance of Estimator class
data: dict of numpy arrays</p>
<blockquote class="last">
<div>realisations of random variables</div></blockquote>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>estimated value</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimator.Estimator.estimate_mult">
<code class="descname">estimate_mult</code><span class="sig-paren">(</span><em>n_chunks=1</em>, <em>re_use=None</em>, <em>**data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimator.html#Estimator.estimate_mult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimator.Estimator.estimate_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate measure for multiple data sets (chunks).</p>
<p>Test if the estimator used provides parallel capabilities; if so,
estimate measure for multiple data sets (&#8216;chunks&#8217;) in parallel.
Otherwise, iterate over individual chunks.</p>
<p>The number of variables in data depends on the measure to be estimated,
e.g., 2 for mutual information and 3 for a conditional mutual
information.</p>
<p>Each entry in data should be a numpy array with realisations, where the
first axis is assumed to represent realisations over samples and
replications and chunks, while the second axis represents the variable
dimension ([(samples * replications) * chunks x variable dimension]).</p>
<p>Each entry in data should be a numpy array with realisations, where the
first axis is assumed to represent realisations (over chunks), while
the second axis is the variable dimension.</p>
<p>Each numpy array with realisations can hold either the realisations for
multiple chunks or can hold the realisation for a single chunk, which
gets replicated for parallel estimation and gets re-used for iterative
estimation, in order to save memory. The variables for re-use are
provided in re-use as list of dictionary keys indicating entries in
data for re-use.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">self : instance of Estimator class
n_chunks : int [optional]</p>
<blockquote>
<div>number of data chunks (default=1)</div></blockquote>
<dl class="last docutils">
<dt>re_use <span class="classifier-delimiter">:</span> <span class="classifier">list of keys [optional}</span></dt>
<dd>realisatins to be re-used (default=None)</dd>
<dt>data: dict of numpy arrays</dt>
<dd>realisations of random variables</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>estimated values for each chunk</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimator.Estimator.is_analytic_null_estimator">
<code class="descname">is_analytic_null_estimator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimator.html#Estimator.is_analytic_null_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimator.Estimator.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports analytic surrogates.</p>
<p>Return true if the estimator implements
estimate_surrogates_analytic(self, n_perm, <a href="#id1"><span class="problematic" id="id2">**</span></a>data) where data is
formatted as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>bool</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimator.Estimator.is_parallel">
<code class="descname">is_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimator.html#Estimator.is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimator.Estimator.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicate if estimator supports parallel estimation over chunks.</p>
<p>Return true if the supports parallel estimation over chunks, where a
chunk is one independent data set.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>bool</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="idtxl.estimator.find_estimator">
<code class="descclassname">idtxl.estimator.</code><code class="descname">find_estimator</code><span class="sig-paren">(</span><em>est</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimator.html#find_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimator.find_estimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return estimator class.</p>
<p>Return an estimator class. If input is a class, check if it implements
methods &#8216;estimate&#8217; and &#8216;is_parallel&#8217; necessary for network analysis
(see abstract class &#8216;Estimator&#8217; for documentation). If input is a string,
search for class with that name in IDTxl and return it.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>est <span class="classifier-delimiter">:</span> <span class="classifier">int | Class</span></dt>
<dd>name of an estimator class implemented in IDTxl or custom estimator
class</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>Class</dt>
<dd>Estimator class</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.estimator.list_estimators">
<code class="descclassname">idtxl.estimator.</code><code class="descname">list_estimators</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimator.html#list_estimators"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimator.list_estimators" title="Permalink to this definition">¶</a></dt>
<dd><p>List all estimators available in IDTxl.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_jidt">
<span id="idtxl-estimators-jidt-module"></span><h2>idtxl.estimators_jidt module<a class="headerlink" href="#module-idtxl.estimators_jidt" title="Permalink to this headline">¶</a></h2>
<p>Provide JIDT estimators.</p>
<dl class="class">
<dt id="idtxl.estimators_jidt.JidtDiscrete">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtDiscrete</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of discrete JIDT-estimators.</p>
<p>Abstract class for implementation of plug-in JIDT-estimators for discrete
data. Child classes implement estimators for mutual information (MI),
conditional mutual information (CMI), actice information storage (AIS), and
transfer entropy (TE). See parent class for references.</p>
<p>Set common estimation parameters for discrete JIDT-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;discretise_method&#8217; - if and how to discretise incoming
continuous variables to discrete values, can be &#8216;max_ent&#8217; for
maximum entropy binning, &#8216;equal&#8217; for equal size bins, and &#8216;none&#8217;
if no binning is required (default=&#8217;none&#8217;)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Discrete JIDT estimators require the data&#8217;s alphabet size for
instantiation. Hence, opposed to the Kraskov and Gaussian estimators,
the JAVA class is added to the object instance, while for Kraskov/
Gaussian estimators an instance of that class is added (because for the
latter, objects can be instantiated independent of data properties).</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscrete.estimate_surrogates_analytic">
<code class="descname">estimate_surrogates_analytic</code><span class="sig-paren">(</span><em>n_perm=200</em>, <em>**data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.estimate_surrogates_analytic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return estimate of the analytical surrogate distribution.</p>
<p>This method must be implemented because this class&#8217;
is_analytic_null_estimator() method returns true.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>n_perms <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>number of permutations (default=200)</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">dict of numpy arrays</span></dt>
<dd>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscrete.get_analytic_distribution">
<code class="descname">get_analytic_distribution</code><span class="sig-paren">(</span><em>**data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.get_analytic_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">dict of numpy arrays</span></dt>
<dd>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Java object</dt>
<dd>JIDT calculator that was used here</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscrete.is_analytic_null_estimator">
<code class="descname">is_analytic_null_estimator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscrete.is_analytic_null_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscrete.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtDiscreteAIS">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtDiscreteAIS</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate AIS with JIDT&#8217;s discrete-variable implementation.</p>
<p>Calculate the active information storage (AIS) for one process. Call JIDT
via jpype and use the discrete estimator. See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;discretise_method&#8217; - if and how to discretise incoming
continuous variables to discrete values, can be &#8216;max_ent&#8217; for
maximum entropy binning, &#8216;equal&#8217; for equal size bins, and &#8216;none&#8217;
if no binning is required (default=&#8217;none&#8217;)</li>
<li>&#8216;num_discrete_bins&#8217; - number of discrete bins/levels or the base
of each dimension of the discrete variables (default=2). If set,
this parameter overwrites/sets &#8216;alph&#8217;</li>
<li>&#8216;history&#8217; - number of samples in the target&#8217;s past used as
embedding</li>
<li>&#8216;alph&#8217; - number of discrete bins/levels for var1 (default=2 , or
the value set for &#8216;num_discrete_bins&#8217;)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteAIS.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>process</em>, <em>return_calc=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</dd>
<dt>return_calc <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>return the calculator used here as well as the numeric
calculated value(s)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average AIS over all samples or local AIS for individual
samples if &#8216;local_values&#8217;=True</dd>
<dt>Java object</dt>
<dd>JIDT calculator that was used here. Only returned if
return_calc was set.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteAIS.get_analytic_distribution">
<code class="descname">get_analytic_distribution</code><span class="sig-paren">(</span><em>process</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteAIS.get_analytic_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteAIS.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations as either a 2D numpy array where array dimensions
represent [realisations x variable dimension] or a 1D array
representing [realisations], array type can be float (requires
discretisation) or int</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Java object</dt>
<dd>JIDT calculator that was used here</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtDiscreteCMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtDiscreteCMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate CMI with JIDT&#8217;s implementation for discrete variables.</p>
<p>Calculate the conditional mutual information between two variables given
the third. Call JIDT via jpype and use the discrete estimator. See parent
class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=&#8217;false&#8217;)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;discretise_method&#8217; - if and how to discretise incoming
continuous variables to discrete values, can be &#8216;max_ent&#8217; for
maximum entropy binning, &#8216;equal&#8217; for equal size bins, and &#8216;none&#8217;
if no binning is required (default=&#8217;none&#8217;)</li>
<li>&#8216;num_discrete_bins&#8217; - number of discrete bins/levels or the base
of each dimension of the discrete variables (default=2). If set,
this parameter overwrites/sets &#8216;alph1&#8217;, &#8216;alph2&#8217; and &#8216;alphc&#8217;</li>
<li>&#8216;alph1&#8217; - number of discrete bins/levels for var1 (default=2, or
the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;alph2&#8217; - number of discrete bins/levels for var2 (default=2, or
the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;alphc&#8217; - number of discrete bins/levels for conditional
(default=2, or the value set for &#8216;num_discrete_bins&#8217;)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteCMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>conditional=None</em>, <em>return_calc=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</dd>
<dt>return_calc <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>return the calculator used here as well as the numeric
calculated value(s)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average CMI over all samples or local CMI for individual
samples if &#8216;local_values&#8217;=True</dd>
<dt>Java object</dt>
<dd>JIDT calculator that was used here. Only returned if
return_calc was set.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteCMI.get_analytic_distribution">
<code class="descname">get_analytic_distribution</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>conditional=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteCMI.get_analytic_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteCMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Java object</dt>
<dd>JIDT calculator that was used here</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtDiscreteMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtDiscreteMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate MI with JIDT&#8217;s discrete-variable implementation.</p>
<p>Calculate the mutual information (MI) between two variables. Call JIDT via
jpype and use the discrete estimator. See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;discretise_method&#8217; - if and how to discretise incoming
continuous variables to discrete values, can be &#8216;max_ent&#8217; for
maximum entropy binning, &#8216;equal&#8217; for equal size bins, and &#8216;none&#8217;
if no binning is required (default=&#8217;none&#8217;)</li>
<li>&#8216;num_discrete_bins&#8217; - number of discrete bins/levels or the base
of each dimension of the discrete variables (default=2). If set,
this parameter overwrites/sets &#8216;alph1&#8217; and &#8216;alph2&#8217;</li>
<li>&#8216;alph1&#8217; - number of discrete bins/levels for var1 (default=2, or
the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;alph2&#8217; - number of discrete bins/levels for var2 (default=2, or
the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;lag&#8217; - time difference in samples to calculate the lagged MI
between processes (default=0)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>return_calc=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>return_calc <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>return the calculator used here as well as the numeric
calculated value(s)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average MI over all samples or local MI for individual
samples if &#8216;local_values&#8217;=True</dd>
<dt>Java object</dt>
<dd>JIDT calculator that was used here. Only returned if
return_calc was set.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteMI.get_analytic_distribution">
<code class="descname">get_analytic_distribution</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteMI.get_analytic_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Java object</dt>
<dd>JIDT calculator that was used here</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtDiscreteTE">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtDiscreteTE</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtDiscrete" title="idtxl.estimators_jidt.JidtDiscrete"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtDiscrete</span></code></a></p>
<p>Calculate TE with JIDT&#8217;s implementation for discrete variables.</p>
<p>Calculate the transfer entropy between two time series processes.
Call JIDT via jpype and use the discrete estimator. Transfer entropy is
defined as the conditional mutual information between the source&#8217;s past
state and the target&#8217;s current value, conditional on the target&#8217;s past.
See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;discretise_method&#8217; - if and how to discretise incoming
continuous variables to discrete values, can be &#8216;max_ent&#8217; for
maximum entropy binning, &#8216;equal&#8217; for equal size bins, and &#8216;none&#8217;
if no binning is required (default=&#8217;none&#8217;)</li>
<li>&#8216;num_discrete_bins&#8217; - number of discrete bins/levels or the base
of each dimension of the discrete variables (default=2). If set,
this parameter overwrites/sets &#8216;alph1&#8217; and &#8216;alph2&#8217;</li>
<li>&#8216;alph1&#8217; - number of discrete bins/levels for source
(default=2, or the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;alph2&#8217; - number of discrete bins/levels for target
(default=2, or the value set for &#8216;num_discrete_bins&#8217;)</li>
<li>&#8216;history_target&#8217; - number of samples in the target&#8217;s past used as
embedding</li>
<li>&#8216;history_source&#8217; - number of samples in the source&#8217;s past used as
embedding (default=same as the target history)</li>
<li>&#8216;tau_source&#8217; - source&#8217;s embedding delay (default=1)</li>
<li>&#8216;tau_target&#8217; - target&#8217;s embedding delay (default=1)</li>
<li>&#8216;source_target_delay&#8217; - information transfer delay between source
and target (default=1)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteTE.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>source</em>, <em>target</em>, <em>return_calc=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of target variable (similar to var1)</dd>
<dt>return_calc <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd>return the calculator used here as well as the numeric
calculated value(s)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average TE over all samples or local TE for individual
samples if &#8216;local_values&#8217;=True</dd>
<dt>Java object</dt>
<dd>JIDT calculator that was used here. Only returned if
return_calc was set.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtDiscreteTE.get_analytic_distribution">
<code class="descname">get_analytic_distribution</code><span class="sig-paren">(</span><em>source</em>, <em>target</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtDiscreteTE.get_analytic_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtDiscreteTE.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations], array type can be
float (requires discretisation) or int</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of target variable (similar to var1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Java object</dt>
<dd>JIDT calculator that was used here</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtEstimator">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtEstimator</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtEstimator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimator.Estimator" title="idtxl.estimator.Estimator"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimator.Estimator</span></code></a></p>
<p>Abstract class for implementation of JIDT estimators.</p>
<p>Abstract class for implementation of JIDT estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), active information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data,
plug-in estimators for discrete data, and Gaussian estimators for
continuous Gaussian data.</p>
<p>References:</p>
<blockquote>
<div><ul class="simple">
<li>Lizier, Joseph T. (2014). JIDT: an information-theoretic toolkit for
studying the dynamics of complex systems. Front Robot AI, 1(11).</li>
<li>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating
mutual information. Phys Rev E, 69(6), 066138.</li>
<li>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed
computation. Inform Sci, 208, 39-54.</li>
<li>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</li>
</ul>
</div></blockquote>
<p>Set common estimation parameters for JIDT estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtEstimator.is_parallel">
<code class="descname">is_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtEstimator.is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtEstimator.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtGaussian">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtGaussian</code><span class="sig-paren">(</span><em>CalcClass</em>, <em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of JIDT Gaussian-estimators.</p>
<p>Abstract class for implementation of JIDT Gaussian-estimators, child
classes implement estimators for mutual information (MI), conditional
mutual information (CMI), actice information storage (AIS), transfer
entropy (TE) using JIDT&#8217;s Gaussian estimator for continuous data. See
parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>CalcClass <span class="classifier-delimiter">:</span> <span class="classifier">JAVA class</span></dt>
<dd>JAVA class returned by jpype.JPackage</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussian.estimate_surrogates_analytic">
<code class="descname">estimate_surrogates_analytic</code><span class="sig-paren">(</span><em>n_perm=200</em>, <em>**data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.estimate_surrogates_analytic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the surrogate distribution analytically.
This method must be implemented because this class&#8217;
is_analytic_null_estimator() method returns true</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><p class="first">n_perms : number of permutations (default 200)
data : array of numpy arrays</p>
<blockquote class="last">
<div>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per estimate_mult for this estimator.</div></blockquote>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussian.get_analytic_distribution">
<code class="descname">get_analytic_distribution</code><span class="sig-paren">(</span><em>**data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.get_analytic_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">dict of numpy arrays</span></dt>
<dd>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for
CMI). Formatted as per the estimate method for this estimator.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Java object</dt>
<dd>JIDT calculator that was used here</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussian.is_analytic_null_estimator">
<code class="descname">is_analytic_null_estimator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussian.is_analytic_null_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussian.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtGaussianAIS">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtGaussianAIS</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate active information storage with JIDT&#8217;s Gaussian implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT&#8217;s
implementation of the Gaussian estimator. AIS is defined as the
mutual information between the processes&#8217; past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes&#8217; past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes&#8217; past.</p>
<p>See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
<li>&#8216;history&#8217; - number of samples in the processes&#8217; past used as
embedding</li>
<li>&#8216;tau&#8217; - the processes&#8217; embedding delay (default=1)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussianAIS.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>process</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianAIS.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average AIS over all samples or local AIS for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtGaussianCMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtGaussianCMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate conditional mutual infor with JIDT&#8217;s Gaussian implementation.</p>
<p>Computes the differential conditional mutual information of two
multivariate sets of observations, conditioned on another, assuming that
the probability distribution function for these observations is a
multivariate Gaussian distribution.
Call JIDT via jpype and use
ConditionalMutualInfoCalculatorMultiVariateGaussian estimator.
If no conditional is given (is None), the function returns the mutual
information between var1 and var2.</p>
<p>See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussianCMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>conditional=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average CMI over all samples or local CMI for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussianCMI.get_analytic_distribution">
<code class="descname">get_analytic_distribution</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>conditional=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianCMI.get_analytic_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianCMI.get_analytic_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a JIDT AnalyticNullDistribution object.</p>
<p>Required so that our estimate_surrogates_analytic method can use the
common_estimate_surrogates_analytic() method, where data is formatted
as per the estimate method for this estimator.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Java object</dt>
<dd>JIDT calculator that was used here</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtGaussianMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtGaussianMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate mutual information with JIDT&#8217;s Gaussian implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Gaussian estimator. See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
<li>&#8216;lag&#8217; - time difference in samples to calculate the lagged MI
between processes (default=0)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussianMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average MI over all samples or local MI for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtGaussianTE">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtGaussianTE</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtGaussian" title="idtxl.estimators_jidt.JidtGaussian"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtGaussian</span></code></a></p>
<p>Calculate transfer entropy with JIDT&#8217;s Gaussian implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT&#8217;s implementation of the Gaussian estimator. Transfer entropy is
defined as the conditional mutual information between the source&#8217;s past
state and the target&#8217;s current value, conditional on the target&#8217;s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable&#8217;s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes&#8217; past.</p>
<p>See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
<li>&#8216;history_target&#8217; - number of samples in the target&#8217;s past used as
embedding</li>
<li>&#8216;history_source&#8217; - number of samples in the source&#8217;s past used as
embedding (default=same as the target history)</li>
<li>&#8216;tau_source&#8217; - source&#8217;s embedding delay (default=1)</li>
<li>&#8216;tau_target&#8217; - target&#8217;s embedding delay (default=1)</li>
<li>&#8216;source_target_delay&#8217; - information transfer delay between source
and target (default=1)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtGaussianTE.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>source</em>, <em>target</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtGaussianTE.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtGaussianTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of target variable (similar to var1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average TE over all samples or local TE for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtKraskov">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtKraskov</code><span class="sig-paren">(</span><em>CalcClass</em>, <em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtEstimator" title="idtxl.estimators_jidt.JidtEstimator"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtEstimator</span></code></a></p>
<p>Abstract class for implementation of JIDT Kraskov-estimators.</p>
<p>Abstract class for implementation of JIDT Kraskov-estimators, child classes
implement estimators for mutual information (MI), conditional mutual
information (CMI), actice information storage (AIS), transfer entropy (TE)
using the Kraskov-Grassberger-Stoegbauer estimator for continuous data.
See parent class for references.</p>
<p>Set common estimation parameters for JIDT Kraskov-estimators. For usage of
these estimators see documentation for the child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>CalcClass <span class="classifier-delimiter">:</span> <span class="classifier">JAVA class</span></dt>
<dd>JAVA class returned by jpype.JPackage</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtKraskov.is_analytic_null_estimator">
<code class="descname">is_analytic_null_estimator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskov.is_analytic_null_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskov.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtKraskovAIS">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtKraskovAIS</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovAIS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate active information storage with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate active information storage (AIS) for some process using JIDT&#8217;s
implementation of the Kraskov type 1 estimator. AIS is defined as the
mutual information between the processes&#8217; past state and current value.</p>
<p>The past state needs to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a processes&#8217; past,
tau describes the embedding delay, i.e., the spacing between every two
samples from the processes&#8217; past.</p>
<p>See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
<li>&#8216;history&#8217; - number of samples in the processes&#8217; past used as
embedding</li>
<li>&#8216;tau&#8217; - the processes&#8217; embedding delay (default=1)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the AIS estimator to save
computation time. The Theiler window ignores trial boundaries. The
AIS estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtKraskovAIS.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>process</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovAIS.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovAIS.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate active information storage.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>process <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average AIS over all samples or local AIS for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtKraskovCMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtKraskovCMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate conditional mutual inform with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables.
Call JIDT via jpype and use the Kraskov 1 estimator. If no conditional is
given (is None), the function returns the mutual information between var1
and var2. See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtKraskovCMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>conditional=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovCMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array [optional]</span></dt>
<dd>realisations of the conditioning variable (similar to var), if
no conditional is provided, return MI between var1 and var2</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average CMI over all samples or local CMI for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtKraskovMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtKraskovMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate mutual information with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate the mutual information between two variables. Call JIDT via jpype
and use the Kraskov 1 estimator. See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
<li>&#8216;lag&#8217; - time difference in samples to calculate the lagged MI
between processes (default=0)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the MI estimator to save
computation time. The Theiler window ignores trial boundaries. The
MI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtKraskovMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average MI over all samples or local MI for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_jidt.JidtKraskovTE">
<em class="property">class </em><code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">JidtKraskovTE</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_jidt.JidtKraskov" title="idtxl.estimators_jidt.JidtKraskov"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_jidt.JidtKraskov</span></code></a></p>
<p>Calculate transfer entropy with JIDT&#8217;s Kraskov implementation.</p>
<p>Calculate transfer entropy between a source and a target variable using
JIDT&#8217;s implementation of the Kraskov type 1 estimator. Transfer entropy is
defined as the conditional mutual information between the source&#8217;s past
state and the target&#8217;s current value, conditional on the target&#8217;s past.</p>
<p>Past states need to be defined in the settings dictionary, where a past
state is defined as a uniform embedding with parameters history and tau.
The history describes the number of samples taken from a variable&#8217;s past,
tau descrices the embedding delay, i.e., the spacing between every two
samples from the processes&#8217; past.</p>
<p>See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">sets estimation parameters:</p>
<ul class="last simple">
<li>&#8216;debug&#8217; - return debug information when calling JIDT.
(Boolean, default=False)</li>
<li>&#8216;local_values&#8217; - return local TE instead of average TE
(default=False)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;num_threads&#8217; - number of threads used for estimation
(default=&#8217;USE_ALL&#8217;, not that this uses <em>all</em> available threads
on the current machine)</li>
<li>&#8216;history_target&#8217; - number of samples in the target&#8217;s past used as
embedding</li>
<li>&#8216;history_source&#8217; - number of samples in the source&#8217;s past used as
embedding (default=same as the target history)</li>
<li>&#8216;tau_source&#8217; - source&#8217;s embedding delay (default=1)</li>
<li>&#8216;tau_target&#8217; - target&#8217;s embedding delay (default=1)</li>
<li>&#8216;source_target_delay&#8217; - information transfer delay between source
and target (default=1)</li>
</ul>
</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>Some technical details: JIDT normalises over realisations, IDTxl
normalises over raw data once, outside the CMI estimator to save
computation time. The Theiler window ignores trial boundaries. The
CMI estimator does add noise to the data as a default. To make analysis
runs replicable set noise_level to 0.</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_jidt.JidtKraskovTE.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>source</em>, <em>target</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#JidtKraskovTE.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.JidtKraskovTE.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate transfer entropy from a source to a target variable.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of source variable, either a 2D numpy array where
array dimensions represent [realisations x variable dimension]
or a 1D array representing [realisations]</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of target variable (similar to var1)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average TE over all samples or local TE for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_jidt.common_estimate_surrogates_analytic">
<code class="descclassname">idtxl.estimators_jidt.</code><code class="descname">common_estimate_surrogates_analytic</code><span class="sig-paren">(</span><em>estimator</em>, <em>n_perm=200</em>, <em>**data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_jidt.html#common_estimate_surrogates_analytic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_jidt.common_estimate_surrogates_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the surrogate distribution analytically for JidtEstimator.</p>
<p>Estimate the surrogate distribution analytically for a JidtEstimator
which is_analytic_null_estimator(), by sampling estimates at random
p-values in the analytic distribution.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>estimator <span class="classifier-delimiter">:</span> <span class="classifier">a JidtEstimator object, which returns True to a call to</span></dt>
<dd>its is_analytic_null_estimator() method</dd>
</dl>
<p>n_perms : number of permutations (default 200)
data : array of numpy arrays</p>
<blockquote class="last">
<div>realisations of random variables required for the calculation
(varies between estimators, e.g. 2 variables for MI, 3 for CMI)</div></blockquote>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>n_perm surrogates of the average MI/CMI/TE over all samples
under the null hypothesis of no relationship between var1 and
var2 (in the context of conditional)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_opencl">
<span id="idtxl-estimators-opencl-module"></span><h2>idtxl.estimators_opencl module<a class="headerlink" href="#module-idtxl.estimators_opencl" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="idtxl.estimators_opencl.OpenCLKraskov">
<em class="property">class </em><code class="descclassname">idtxl.estimators_opencl.</code><code class="descname">OpenCLKraskov</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimator.Estimator" title="idtxl.estimator.Estimator"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimator.Estimator</span></code></a></p>
<p>Abstract class for implementation of OpenCL estimators.</p>
<p>Abstract class for implementation of OpenCL estimators, child classes
implement estimators for mutual information (MI) and conditional mutual
information (CMI) using the Kraskov-Grassberger-Stoegbauer estimator for
continuous data.</p>
<p>References:</p>
<blockquote>
<div><ul class="simple">
<li>Kraskov, A., Stoegbauer, H., &amp; Grassberger, P. (2004). Estimating
mutual information. Phys Rev E, 69(6), 066138.</li>
<li>Lizier, Joseph T., Mikhail Prokopenko, and Albert Y. Zomaya. (2012).
Local measures of information storage in complex distributed
computation. Inform Sci, 208, 39-54.</li>
<li>Schreiber, T. (2000). Measuring information transfer. Phys Rev Lett,
85(2), 461.</li>
</ul>
</div></blockquote>
<p>Estimators can be used to perform multiple, independent searches in
parallel. Each of these parallel searches is called a &#8216;chunk&#8217;. To search
multiple chunks, provide point sets as 2D arrays, where the first
dimension represents samples or points, and the second dimension
represents the points&#8217; dimensions. Concatenate chunk data in the first
dimension and pass the number of chunks to the estimators. Chunks must be
of equal size.</p>
<p>Set common estimation parameters for OpenCL estimators. For usage of these
estimators see documentation for the child classes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;gpuid&#8217; - device ID used for estimation (if more than one device
is available on the current platform) (default=0)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;debug&#8217; - return intermediate results, i.e. neighbour counts from
range searches and KNN distances (default=False)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_opencl.OpenCLKraskov.is_analytic_null_estimator">
<code class="descname">is_analytic_null_estimator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_analytic_null_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.estimators_opencl.OpenCLKraskov.is_parallel">
<code class="descname">is_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskov.is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskov.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_opencl.OpenCLKraskovCMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_opencl.</code><code class="descname">OpenCLKraskovCMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovCMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_opencl.OpenCLKraskov" title="idtxl.estimators_opencl.OpenCLKraskov"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_opencl.OpenCLKraskov</span></code></a></p>
<p>Calculate conditional mutual inform with OpenCL Kraskov implementation.</p>
<p>Calculate the conditional mutual information (CMI) between three variables
using OpenCL GPU-code. If no conditional is given (is None), the function
returns the mutual information between var1 and var2. See parent class for
references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;gpuid&#8217; - device ID used for estimation (if more than one device
is available on the current platform) (default=0)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;debug&#8217; - return intermediate results, i.e. neighbour counts from
range searches and KNN distances (default=False)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_opencl.OpenCLKraskovCMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>conditional=None</em>, <em>n_chunks=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovCMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovCMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate conditional mutual information.</p>
<p>If conditional is None, the mutual information between var1 and var2 is
calculated.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, a 2D numpy array where array
dimensions represent [(realisations * n_chunks) x variable
dimension], array type should be int32</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>conditional <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of conditioning variable (similar to var1)</dd>
<dt>n_chunks <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of data chunks, no. data points has to be the same for
each chunk</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average CMI over all samples or local CMI for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_opencl.OpenCLKraskovMI">
<em class="property">class </em><code class="descclassname">idtxl.estimators_opencl.</code><code class="descname">OpenCLKraskovMI</code><span class="sig-paren">(</span><em>settings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovMI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimators_opencl.OpenCLKraskov" title="idtxl.estimators_opencl.OpenCLKraskov"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimators_opencl.OpenCLKraskov</span></code></a></p>
<p>Calculate mutual information with OpenCL Kraskov implementation.</p>
<p>Calculate the mutual information (MI) between two variables using OpenCL
GPU-code. See parent class for references.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">set estimator parameters:</p>
<ul class="last simple">
<li>&#8216;gpuid&#8217; - device ID used for estimation (if more than one device
is available on the current platform) (default=0)</li>
<li>&#8216;kraskov_k&#8217; - no. nearest neighbours for KNN search (default=4)</li>
<li>&#8216;normalise&#8217; - z-standardise data (default=False)</li>
<li>&#8216;theiler_t&#8217; - no. next temporal neighbours ignored in KNN and
range searches (default=&#8216;0&#8217;)</li>
<li>&#8216;noise_level&#8217; - random noise added to the data (default=&#8216;1e-8&#8217;)</li>
<li>&#8216;debug&#8217; - return intermediate results, i.e. neighbour counts from
range searches and KNN distances (default=False)</li>
<li>&#8216;lag&#8217; - time difference in samples to calculate the lagged MI
between processes (default=0)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_opencl.OpenCLKraskovMI.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>var1</em>, <em>var2</em>, <em>n_chunks=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_opencl.html#OpenCLKraskovMI.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_opencl.OpenCLKraskovMI.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate mutual information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>var1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of first variable, a 2D numpy array where array
dimensions represent [(realisations * n_chunks) x variable
dimension], array type should be int32</dd>
<dt>var2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>realisations of the second variable (similar to var1)</dd>
<dt>n_chunks <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of data chunks, no. data points has to be the same for
each chunk</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float | numpy array</dt>
<dd>average MI over all samples or local MI for individual
samples if &#8216;local_values&#8217;=True</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.estimators_pid">
<span id="idtxl-estimators-pid-module"></span><h2>idtxl.estimators_pid module<a class="headerlink" href="#module-idtxl.estimators_pid" title="Permalink to this headline">¶</a></h2>
<p>Partical information decomposition for discrete random variables.</p>
<p>This module provides an estimator for partial information decomposition
as proposed in</p>
<p>Bertschinger, Rauh, Olbrich, Jost, Ay; Quantifying Unique Information,
Entropy 2014, 16, 2161-2183; doi:10.3390/e16042161</p>
<dl class="class">
<dt id="idtxl.estimators_pid.SydneyPID">
<em class="property">class </em><code class="descclassname">idtxl.estimators_pid.</code><code class="descname">SydneyPID</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimator.Estimator" title="idtxl.estimator.Estimator"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimator.Estimator</span></code></a></p>
<p>Estimate partial information decomposition of discrete variables.</p>
<p>Fast implementation of the partial information decomposition (PID)
estimator for discrete data. The estimator does not require JAVA or GPU
modules to run.</p>
<p>The estimator finds shared information, unique information and
synergistic information between the two inputs s1 and s2 with respect to
the output t.</p>
<p>Improved version with larger initial swaps and checking for convergence of
both the unique information from sources 1 and 2. The function counts the
empirical observations, calculates probabilities and the initial CMI, then
does the vitrualised swaps until it has converged, and finally calculates
the PID. The virtualised swaps stage contains two loops. An inner loop
which actually does the virtualised swapping, keeping the changes if the
CMI decreases; and an outer loop which decreases the size of the
probability mass increment the virtualised swapping utilises.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">estimation parameters</p>
<ul class="last simple">
<li>&#8216;alph_s1&#8217; - alphabet size of s1</li>
<li>&#8216;alph_s2&#8217; -  alphabet size of s2</li>
<li>&#8216;alph_t&#8217; - alphabet size of t</li>
<li>&#8216;max_unsuc_swaps_row_parm&#8217; - soft limit for virtualised swaps
based on the number of unsuccessful swaps attempted in a row.
If there are too many unsuccessful swaps in a row, then it
will break the inner swap loop; the outer loop decrements the
size of the probability mass increment and then attemps
virtualised swaps again with the smaller probability increment.
The exact number of unsuccessful swaps allowed before breaking
is the total number of possible swaps (given our alphabet
sizes) times the control parameter &#8216;max_unsuc_swaps_row_parm&#8217;,
e.g., if the parameter is set to 3, this gives a high degree of
confidence that nearly (if not) all of the possible swaps have
been attempted before this soft limit breaks the swap loop.</li>
<li>&#8216;num_reps&#8217; -  number of times the outer loop will halve the
size of the probability increment used for the virtualised
swaps. This is in direct correspondence with the number of times
the empirical data was replicated in your original
implementation.</li>
<li>&#8216;max_iters&#8217; - provides a hard upper bound on the number of times
it will attempt to perform virtualised swaps in the inner loop.
However, this hard limit is (practically) never used as it should
always hit the soft limit defined above (parameter may be removed
in the future).</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_pid.SydneyPID.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em>, <em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>s1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable</dd>
<dt>s2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable</dd>
<dt>t <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>estimated decomposition, contains the joint distribution,
unique, shared, and synergistic information</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_pid.SydneyPID.is_analytic_null_estimator">
<code class="descname">is_analytic_null_estimator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_analytic_null_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.estimators_pid.SydneyPID.is_parallel">
<code class="descname">is_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#SydneyPID.is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.SydneyPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="idtxl.estimators_pid.TartuPID">
<em class="property">class </em><code class="descclassname">idtxl.estimators_pid.</code><code class="descname">TartuPID</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.estimator.Estimator" title="idtxl.estimator.Estimator"><code class="xref py py-class docutils literal"><span class="pre">idtxl.estimator.Estimator</span></code></a></p>
<p>Estimate partial information decomposition for two inputs and one output</p>
<p>Fast implementation of the partial information decomposition (PID)
estimator for discrete data. The estimator does require a gurobi
installation.</p>
<p>The estimator finds shared information, unique information and
synergistic information between the two inputs s1 and s2 with respect to
the output t.</p>
<p>Improved version with larger initial swaps and checking for convergence of
both the unique information from sources 1 and 2.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">estimation parameters (with default parameters)</p>
<ul class="last simple">
<li>&#8216;get_sorted_pdf&#8217; -False</li>
<li>&#8216;true_pdf&#8217; - None</li>
<li>&#8216;true_result&#8217; - None</li>
<li>&#8216;true_CI&#8217; - None</li>
<li>&#8216;true_SI&#8217; - None</li>
<li>&#8216;feas_eps&#8217; - 1.e-10</li>
<li>&#8216;kkt_eps&#8217; - 1.e-5</li>
<li>&#8216;feas_eps_2&#8217; - 1.e-6</li>
<li>&#8216;kkt_eps_2&#8217; - 0.01</li>
<li>&#8216;kkt_search_eps&#8217; - 0.5</li>
<li>&#8216;max_zero_probability&#8217; - 1.e-5</li>
<li>&#8216;verbose&#8217; - False</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.estimators_pid.TartuPID.estimate">
<code class="descname">estimate</code><span class="sig-paren">(</span><em>s1</em>, <em>s2</em>, <em>t</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.estimate" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>s1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable</dd>
<dt>s2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable</dd>
<dt>t <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>estimated decomposition, contains the optimised PDF, shared,
and synergistic information</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.estimators_pid.TartuPID.is_analytic_null_estimator">
<code class="descname">is_analytic_null_estimator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_analytic_null_estimator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.is_analytic_null_estimator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.estimators_pid.TartuPID.is_parallel">
<code class="descname">is_parallel</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#TartuPID.is_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.TartuPID.is_parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="idtxl.estimators_pid.pid_frankfurt">
<code class="descclassname">idtxl.estimators_pid.</code><code class="descname">pid_frankfurt</code><span class="sig-paren">(</span><em>self</em>, <em>s1</em>, <em>s2</em>, <em>t</em>, <em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/estimators_pid.html#pid_frankfurt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.estimators_pid.pid_frankfurt" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition of discrete variables.</p>
<p>The pid estimator returns estimates of shared information, unique
information and synergistic information that two random variables X and
Y have about a third variable Z. The estimator finds these estimates by
permuting the initial joint probability distribution of X, Y, and Z to
find a permuted distribution Q that minimizes the unique information in
X about Z (as proposed by Bertschinger and colleagues). The unique in-
formation is defined as the conditional mutual information I(X;Z|Y).</p>
<p>The estimator iteratively permutes the joint probability distribution of
X, Y, and Z under the constraint that the marginal distributions (X, Z)
and (Y, Z) stay constant. This is done by swapping two realizations of X
which have the same corresponding value in Z, e.g.:</p>
<blockquote>
<div><p>X [1, 0, 1, 1, 0, 1, 0, 0, 1, 1]
Y [0, 0, 1, 1, 1, 0, 0, 0, 1, 1]
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;
Z [1, 1, 0, 0, 0, 1, 1, 0, 1, 0]</p>
<p>Possible swaps: X[0] and X[1]; X[0] and X[4]; X[2] and X[8]; ...</p>
</div></blockquote>
<p>After each swap, I(X;Z|Y) is re-calculated under the new distribution;
if the CMI is lower than the current permutation is kept and the next
swap is tested. The iteration stops after the provided number of
iterations.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><p class="first">import numpy as np
import pid</p>
<p>n = 5000
alph = 2
x = np.random.randint(0, alph, n)
y = np.random.randint(0, alph, n)
z = np.logical_xor(x, y).astype(int)
cfg = {</p>
<blockquote>
<div>&#8216;alphabetsize&#8217;: 2,
&#8216;jarpath&#8217;: &#8216;/home/user/infodynamics-dist-1.3/infodynamics.jar&#8217;,
&#8216;iterations&#8217;: 10000</div></blockquote>
<p class="last">}
[est, opt] = pid(x, y, z, cfg)</p>
</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>s1 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable
(this is the source variable the algorithm calculates the actual
UI for)</dd>
<dt>s2 <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable (the
other source variable)</dd>
<dt>t <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>1D array containing realizations of a discrete random variable</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">estimation parameters</p>
<ul class="last simple">
<li>&#8216;alphabetsize&#8217; - no. values in each variable s1, s2, t</li>
<li>&#8216;jarpath&#8217; - string with path to JIDT jar file</li>
<li>&#8216;iterations&#8217; - no. iterations of the estimator</li>
</ul>
</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>estimated decomposition, contains: MI/CMI values computed
from non-permuted distributions; PID estimates (shared,
synergistic, unique information); I(target;s1,s2) under permuted
distribution Q</dd>
<dt>dict</dt>
<dd>additional information about iterative optimization,
contains: final permutation Q; settings dictionary; array with
I(target:s1|s2) for each iteration; array with delta
I(target:s1|s2) for each iteration; I(target:s1,s2) for each
iteration</dd>
</dl>
</dd>
<dt>Note:</dt>
<dd>variables names joined by &#8220;_&#8221; enter a mutual information computation
together i.e. mi_va1_var2 &#8211;&gt; I(var1 : var2). Variables names joined
directly form a new joint variable
mi_var1var2_var3 &#8211;&gt; I(var3:(var1,var2))</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_exceptions">
<span id="idtxl-idtxl-exceptions-module"></span><h2>idtxl.idtxl_exceptions module<a class="headerlink" href="#module-idtxl.idtxl_exceptions" title="Permalink to this headline">¶</a></h2>
<p>Provide error handling and warnings.</p>
<dl class="function">
<dt id="idtxl.idtxl_exceptions.package_missing">
<code class="descclassname">idtxl.idtxl_exceptions.</code><code class="descname">package_missing</code><span class="sig-paren">(</span><em>err</em>, <em>message</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_exceptions.html#package_missing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_exceptions.package_missing" title="Permalink to this definition">¶</a></dt>
<dd><p>Report a missing optional package upon import.</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_import">
<span id="idtxl-idtxl-import-module"></span><h2>idtxl.idtxl_import module<a class="headerlink" href="#module-idtxl.idtxl_import" title="Permalink to this headline">¶</a></h2>
<p>Import external file formats into IDTxl.</p>
<p>Provide functions to import the following into IDTxl:</p>
<blockquote>
<div><ul class="simple">
<li>mat-files (version&gt;7.3, hdf5)</li>
<li>FieldTrip-style mat-files (version&gt;7.3, hdf5)</li>
</ul>
</div></blockquote>
<p>Matlab supports hdf5 only for files saved as version 7.3 or higher:
<a class="reference external" href="https://au.mathworks.com/help/matlab/ref/save.html#inputarg_version">https://au.mathworks.com/help/matlab/ref/save.html#inputarg_version</a></p>
<p>Creates a numpy array usable as input to IDTxl.</p>
<dl class="docutils">
<dt>Methods:</dt>
<dd><p class="first">ft_trial_2_numpyarray(file_name, ft_struct_name)
matarray2idtxlconverter(file_name, array_name, order) =     takes a file_name,</p>
<blockquote class="last">
<div>the name of the array variable (array_name) inside,
and the order of sensor axis,  time axisand (CHECK THIS!!)
repetition axis (as a list)</div></blockquote>
</dd>
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>Created on Wed Mar 19 12:34:36 2014</p>
<p>&#64;author: Michael Wibral</p>
<dl class="function">
<dt id="idtxl.idtxl_import.import_fieldtrip">
<code class="descclassname">idtxl.idtxl_import.</code><code class="descname">import_fieldtrip</code><span class="sig-paren">(</span><em>file_name</em>, <em>ft_struct_name</em>, <em>file_version</em>, <em>normalise=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_import.html#import_fieldtrip"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_import.import_fieldtrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert FieldTrip-style MATLAB-file into an IDTxl Data object.</p>
<p>Import a MATLAB structure with fields  &#8220;trial&#8221; (data), &#8220;label&#8221; (channel
labels), &#8220;time&#8221; (time stamps for data samples), and &#8220;fsample&#8221; (sampling
rate). This structure is the standard file format in the MATLAB toolbox
FieldTrip and commonly use to represent neurophysiological data (see also
<a class="reference external" href="http://www.fieldtriptoolbox.org/reference/ft_datatype_raw">http://www.fieldtriptoolbox.org/reference/ft_datatype_raw</a>). The data is
returned as a IDTxl Data() object.</p>
<p>The structure is assumed to be saved as a matlab hdf5 file (&#8220;-v7.3&#8217; or
higher, .mat) with a SINGLE FieldTrip data structure inside.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>full (matlab) file_name on disk</dd>
<dt>ft_struct_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>variable name of the MATLAB structure that is in FieldTrip format
(autodetect will hopefully be possible later ...)</dd>
<dt>file_version <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>version of the file, e.g. &#8216;v7.3&#8217; for MATLAB&#8217;s 7.3 format</dd>
<dt>normalise <span class="classifier-delimiter">:</span> <span class="classifier">bool [optional]</span></dt>
<dd>normalise data after import (default=True)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Data() instance</dt>
<dd>instance of IDTxl Data object, containing data from the &#8216;trial&#8217;
field</dd>
<dt>list of strings</dt>
<dd>list of channel labels, corresponding to the &#8216;label&#8217; field</dd>
<dt>numpy array</dt>
<dd>time stamps for samples, corresponding to one entry in the &#8216;time&#8217;
field</dd>
<dt>int</dt>
<dd>sampling rate, corresponding to the &#8216;fsample&#8217; field</dd>
</dl>
</dd>
</dl>
<p>&#64;author: Michael Wibral</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_import.import_matarray">
<code class="descclassname">idtxl.idtxl_import.</code><code class="descname">import_matarray</code><span class="sig-paren">(</span><em>file_name</em>, <em>array_name</em>, <em>file_version</em>, <em>dim_order</em>, <em>normalise=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_import.html#import_matarray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_import.import_matarray" title="Permalink to this definition">¶</a></dt>
<dd><p>Read Matlab hdf5 file into IDTxl.</p>
<p>reads a matlab hdf5 file (&#8220;-v7.3&#8217; or higher, .mat) with a SINGLE
array inside and returns a numpy array with dimensions that
are channel x time x trials, using np.swapaxes where necessary</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>The import function squeezes the loaded mat-file, i.e., any singleton
dimension will be removed. Hence do not enter singleton dimension into
the &#8216;dim_order&#8217;, e.g., don&#8217;t pass dim_order=&#8217;ps&#8217; but dim_order=&#8217;s&#8216; if
you want to load a 1D-array where entries represent samples recorded
from a single channel.</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>full (matlab) file_name on disk</dd>
<dt>array_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>variable name of the MATLAB structure to be read</dd>
<dt>file_version <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>version of the file, e.g. &#8216;v7.3&#8217; for MATLAB&#8217;s 7.3 format, currently
versions &#8216;v4&#8217;, &#8216;v6&#8217;, &#8216;v7&#8217;, and &#8216;v7&#8217; are supported</dd>
<dt>dim_order <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>order of dimensions, accepts any combination of the characters
&#8216;p&#8217;, &#8216;s&#8217;, and &#8216;r&#8217; for processes, samples, and replications; must
have the same length as the data dimensionality, e.g., &#8216;ps&#8217; for a
two-dimensional array of data from several processes over time</dd>
<dt>normalise <span class="classifier-delimiter">:</span> <span class="classifier">bool [optional]</span></dt>
<dd>normalise data after import (default=True)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>Data() instance</dt>
<dd>instance of IDTxl Data object, containing data from the &#8216;trial&#8217;
field</dd>
<dt>list of strings</dt>
<dd>list of channel labels, corresponding to the &#8216;label&#8217; field</dd>
<dt>numpy array</dt>
<dd>time stamps for samples, corresponding to one entry in the &#8216;time&#8217;
field</dd>
<dt>int</dt>
<dd>sampling rate, corresponding to the &#8216;fsample&#8217; field</dd>
</dl>
</dd>
</dl>
<p>Created on Wed Mar 19 12:34:36 2014</p>
<p>&#64;author: Michael Wibral</p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_io">
<span id="idtxl-idtxl-io-module"></span><h2>idtxl.idtxl_io module<a class="headerlink" href="#module-idtxl.idtxl_io" title="Permalink to this headline">¶</a></h2>
<p>Provide load and save functionality for IDTxl results.</p>
<dl class="function">
<dt id="idtxl.idtxl_io.load">
<code class="descclassname">idtxl.idtxl_io.</code><code class="descname">load</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#load"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_io.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Load IDTxl data from disk.</p>
<p>Load different data types to disk. Supported types are:</p>
<ul class="simple">
<li>dictionaries with results, e.g., from MultivariateTE</li>
<li>numpy array</li>
<li>instance of IDTXL Data object</li>
</ul>
<p>File extensions are</p>
<ul class="simple">
<li>.txt for dictionaries (JSON file)</li>
<li>.npy for numpy array</li>
<li>.npz for Data instances</li>
</ul>
<p>Note that while numpy arrays and Data instances are saved in binary for
performance, dictionaries are saved in the json format, which is human-
readable and also easily read into other programs (e.g., MATLAB:
<a class="reference external" href="http://undocumentedmatlab.com/blog/json-matlab-integration">http://undocumentedmatlab.com/blog/json-matlab-integration</a>).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>string with file name (including the path)</dd>
</dl>
</dd>
</dl>
<p>Returns:</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_io.load_pickle">
<code class="descclassname">idtxl.idtxl_io.</code><code class="descname">load_pickle</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#load_pickle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_io.load_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Load objects that have been saved using Python&#8217;s pickle module.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_io.save">
<code class="descclassname">idtxl.idtxl_io.</code><code class="descname">save</code><span class="sig-paren">(</span><em>dat</em>, <em>file_path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_io.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Save IDTxl data to disk.</p>
<p>Save different data types to disk. Supported types are:</p>
<ul class="simple">
<li>dictionaries with results, e.g., from MultivariateTE</li>
<li>numpy array</li>
<li>instance of IDTXL Data object</li>
</ul>
<p>Note that while numpy arrays and Data instances are saved in binary for
performance, dictionaries are saved in the json format, which is human-
readable and also easily read into other programs (e.g., MATLAB:
<a class="reference external" href="http://undocumentedmatlab.com/blog/json-matlab-integration">http://undocumentedmatlab.com/blog/json-matlab-integration</a>).</p>
<p>File extensions are</p>
<ul class="simple">
<li>.txt for dictionaries (JSON file)</li>
<li>.npy for numpy array</li>
<li>.npz for Data instances</li>
</ul>
<p>If the extension is not provided in the file_path, the function will add it
depending on the type of the data to be written.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>dat <span class="classifier-delimiter">:</span> <span class="classifier">dict | numpy array | Data object</span></dt>
<dd>data to be saved to disk</dd>
<dt>file_path <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>string with file name (including the path)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_io.save_pickle">
<code class="descclassname">idtxl.idtxl_io.</code><code class="descname">save_pickle</code><span class="sig-paren">(</span><em>obj</em>, <em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_io.html#save_pickle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_io.save_pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Save objects using Python&#8217;s pickle module.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>pickle.HIGHEST_PROTOCOL is a binary format, which may be inconvenient,
but is good for performance. Protocol 0 is a text format.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.idtxl_utils">
<span id="idtxl-idtxl-utils-module"></span><h2>idtxl.idtxl_utils module<a class="headerlink" href="#module-idtxl.idtxl_utils" title="Permalink to this headline">¶</a></h2>
<p>Provide IDTxl utility functions.</p>
<dl class="function">
<dt id="idtxl.idtxl_utils.argsort_descending">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">argsort_descending</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#argsort_descending"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.argsort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order and return sortind indices.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.autocorrelation">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">autocorrelation</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#autocorrelation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate autocorrelation of a vector.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.combine_discrete_dimensions">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">combine_discrete_dimensions</code><span class="sig-paren">(</span><em>a</em>, <em>numBins</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#combine_discrete_dimensions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.combine_discrete_dimensions" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine multi-dimensional discrete variable into a single dimension.</p>
<p>Combine all dimensions for a discrete variable down into a single
dimensional value for each sample. This is done basically by multiplying
each dimension by a different power of the base (numBins).</p>
<p>Adapted from infodynamics.utils.MatrixUtils.computeCombinedValues() from
JIDT by J.Lizier.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be combined across all variable dimensions. Dimensions are
realisations (samples) x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins for each variable dimension</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>a univariate array &#8211; one entry now for each sample,
with all dimensions of the data now combined for that sample</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.combine_results">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">combine_results</code><span class="sig-paren">(</span><em>*results</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#combine_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.combine_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine partial results into single results dictionary.</p>
<p>Combine a list of partial network inference results into a single results
dictionary (e.g., results from analysis parallelized over target nodes).
Raise an error if duplicate keys, i.e., duplicate targets, occur in
partial results. Remove FDR-corrections from partial results before
combining them. Corrections performed on the basis of parts of the network
a not valid for the combined network.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>results <span class="classifier-delimiter">:</span> <span class="classifier">list of dicts</span></dt>
<dd>network inference results from .analyse_network methods, where each
dict entry represents results for one target node</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>combined results dict</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.discretise">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">discretise</code><span class="sig-paren">(</span><em>a</em>, <em>numBins</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data into discrete values (with 0 as lowest)
by evenly partitioning the range of the data, one dimension at a time.
Adapted from infodynamics.utils.MatrixUtils.discretise() from JIDT by J.Lizier</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be discretised. Dimensions are
realisations x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins to partition the data into</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>discretised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.discretise_max_ent">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">discretise_max_ent</code><span class="sig-paren">(</span><em>a</em>, <em>numBins</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#discretise_max_ent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.discretise_max_ent" title="Permalink to this definition">¶</a></dt>
<dd><p>Discretise continuous data into discrete values (with 0 as lowest)
by making a maximum entropy partitioning, one dimension at a time.
Adapted from infodynamics.utils.MatrixUtils.discretiseMaxEntropy() from JIDT by J.Lizier</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be discretised. Dimensions are
realisations x variable dimension</dd>
<dt>numBins <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of discrete levels or bins to partition the data into</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>discretised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.print_dict">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">print_dict</code><span class="sig-paren">(</span><em>d</em>, <em>indent=4</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#print_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.print_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Use Python&#8217;s pretty printer to print dictionaries to the console.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.remove_column">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">remove_column</code><span class="sig-paren">(</span><em>a</em>, <em>j</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_column"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a column from a numpy array.</p>
<p>This is faster than logical indexing (&#8216;25 times faster&#8217;), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2-dimensional numpy array</dd>
<dt>i <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>column index to be removed</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.remove_row">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">remove_row</code><span class="sig-paren">(</span><em>a</em>, <em>i</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#remove_row"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.remove_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove a row from a numpy array.</p>
<p>This is faster than logical indexing (&#8216;25 times faster&#8217;), because it does
not make copies, see
<a class="reference external" href="http://scipy.github.io/old-wiki/pages/PerformanceTips">http://scipy.github.io/old-wiki/pages/PerformanceTips</a></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2-dimensional numpy array</dd>
<dt>i <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>row index to be removed</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.separate_arrays">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">separate_arrays</code><span class="sig-paren">(</span><em>idx_all</em>, <em>idx_single</em>, <em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#separate_arrays"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.separate_arrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Separate a single column from all other columns in a 2D-array.</p>
<p>Return the separated single column and the remaining columns of a 2D-
array.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>idx_all <span class="classifier-delimiter">:</span> <span class="classifier">list&lt;Object&gt;</span></dt>
<dd>list of variables indicating the full set</dd>
<dt>idx_single <span class="classifier-delimiter">:</span> <span class="classifier">&lt;Object&gt;</span></dt>
<dd>single variable indicating the column to be separated, variable
must be contained in idx_all</dd>
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>2D-array with the same length along axis 1 as idx_all
(.shape[1] == len(idx_all))</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>remaining columns in full array</dd>
<dt>numpy array</dt>
<dd>column at single index</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.sort_descending">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">sort_descending</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#sort_descending"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.sort_descending" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort array in descending order.</p>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.standardise">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">standardise</code><span class="sig-paren">(</span><em>a</em>, <em>dimension=0</em>, <em>df=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#standardise"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.standardise" title="Permalink to this definition">¶</a></dt>
<dd><p>Z-standardise a numpy array along a given dimension.</p>
<p>Standardise array along the axis defined in dimension using the denominator
(N - df) for the calculation of the standard deviation.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>data to be standardised</dd>
<dt>dimension <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>dimension along which array should be standardised</dd>
<dt>df <span class="classifier-delimiter">:</span> <span class="classifier">int [optional]</span></dt>
<dd>degrees of freedom for the denominator of the standard derivation</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>standardised data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.idtxl_utils.swap_chars">
<code class="descclassname">idtxl.idtxl_utils.</code><code class="descname">swap_chars</code><span class="sig-paren">(</span><em>s</em>, <em>i_1</em>, <em>i_2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/idtxl_utils.html#swap_chars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.idtxl_utils.swap_chars" title="Permalink to this definition">¶</a></dt>
<dd><p>Swap to characters in a string.</p>
<dl class="docutils">
<dt>Example:</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">swap_chars</span><span class="p">(</span><span class="s1">&#39;heLlotHere&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="go">&#39;heHlotLere&#39;</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.multivariate_spectral_te">
<span id="idtxl-multivariate-spectral-te-module"></span><h2>idtxl.multivariate_spectral_te module<a class="headerlink" href="#module-idtxl.multivariate_spectral_te" title="Permalink to this headline">¶</a></h2>
<p>Estimate multivarate spectral TE.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: edoardo</p>
<dl class="class">
<dt id="idtxl.multivariate_spectral_te.MultivariateSpectralTE">
<em class="property">class </em><code class="descclassname">idtxl.multivariate_spectral_te.</code><code class="descname">MultivariateSpectralTE</code><span class="sig-paren">(</span><em>settings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_spectral_te.html#MultivariateSpectralTE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_spectral_te.MultivariateSpectralTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
<p>Set up a network analysis using multivariate spectral transfer entropy.</p>
<p>Set parameters necessary for inference of spectral components of
multivariate transfer entropy (TE). To perform network inference call
analyse_network() on an instance of the data class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimator use and statistics:</p>
<ul class="last simple">
<li>&#8216;cmi_estimator&#8217; - estimator to be used for CMI calculation
(For estimator settings see the respective documentation.)</li>
<li>&#8216;n_perm_spec&#8217; - number of permutations (default=200)</li>
<li>&#8216;alpha_spec&#8217; - critical alpha level for statistical significance
(default=0.05)</li>
<li>&#8216;cmi_estimator&#8217; - estimator to be used for CMI calculation
(For estimator settings see the respective documentation.)</li>
<li>&#8216;permute_in_time&#8217; - force surrogate creation by shuffling
realisations in time instead of shuffling replications; see
documentation of Data.permute_samples() for further settings
(default=False)</li>
</ul>
</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.multivariate_spectral_te.MultivariateSpectralTE.analyse_network">
<code class="descname">analyse_network</code><span class="sig-paren">(</span><em>res_network</em>, <em>data</em>, <em>targets='all'</em>, <em>sources='all'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_spectral_te.html#MultivariateSpectralTE.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_spectral_te.MultivariateSpectralTE.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate spectral transfer entropy between all nodes.</p>
<p>Estimate multivariate transfer entropy (TE) between all nodes in the
network or between selected sources and targets.</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_lag</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_lag</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">min_lag</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                  <span class="n">settings</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">dat</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_spec&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha_spec&#39;</span><span class="p">:</span> <span class="mf">0.05</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_analysis</span> <span class="o">=</span> <span class="n">Multivariate_spectral_te</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_spec</span> <span class="o">=</span> <span class="n">spectral_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">spectral_settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">res</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Note:</dt>
<dd>For more details on the estimation of multivariate transfer entropy
see documentation of class method &#8216;analyse_single_target&#8217;.</dd>
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res_network: dict</dt>
<dd>results from multivariate network inference, e.g., using TE</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data from which the network was inferred</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">list of int | &#8216;all&#8217; [optional]</span></dt>
<dd>index of target processes (default=&#8217;all&#8217;)</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | list of list | &#8216;all&#8217; [optional]</span></dt>
<dd>indices of source processes for each target (default=&#8217;all&#8217;);
if &#8216;all&#8217;, all identified sources in the network are tested for
spectral TE;
if list of int, sources specified in the list are tested for
each target;
if list of list, sources specified in each inner list are
tested for the corresponding target</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd><p class="first">results consisting of</p>
<ul class="simple">
<li>TODO to be specified ...</li>
</ul>
<p class="last">for each target</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.multivariate_spectral_te.MultivariateSpectralTE.analyse_single_target">
<code class="descname">analyse_single_target</code><span class="sig-paren">(</span><em>res_target</em>, <em>data</em>, <em>sources='all'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_spectral_te.html#MultivariateSpectralTE.analyse_single_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_spectral_te.MultivariateSpectralTE.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate spectral transfer entropy into a target.</p>
<p>Test multivariate spectral transfer entropy (TE) between all source
identified using multivariate TE and a target:</p>
<ol class="arabic simple">
<li>take one relevant variable s</li>
<li>perform a maximal overlap discrete wavelet transform (MODWT)</li>
<li>destroy information carried by a single frequency band by
scrambling the coefficients in the respective scale</li>
<li>perform the inverse of the MODWT, iMODWT, to get back the time-
domain representation of the variable</li>
<li>calculate multivariate TE between s and the target, conditional on
all other relevant sources</li>
<li>repeat (3) to (5) n_perm number of times to build a test
distribution</li>
<li>test original multivariate TE against the test distribution</li>
</ol>
<p>Example:</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">max_lag</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_lag</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">(</span><span class="n">max_lag</span><span class="p">,</span> <span class="n">min_lag</span><span class="p">,</span> <span class="n">settings</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">dat</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_spec&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha_spec&#39;</span><span class="p">:</span> <span class="mf">0.05</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">spectral_analysis</span> <span class="o">=</span> <span class="n">Multivariate_spectral_te</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res_spec</span> <span class="o">=</span> <span class="n">spectral_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span>                                    <span class="n">spectral_settingsres</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span>
</pre></div>
</div>
<p>Note:
For more details on the estimation of multivariate transfer entropy
see documentation of class method &#8216;analyse_single_target&#8217;.</p>
<p>Args:
res_network: dict</p>
<blockquote>
<div>results from multivariate network inference, e.g., using TE</div></blockquote>
<dl class="docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data from which the network was inferred</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | int | &#8216;all&#8217; [optional]</span></dt>
<dd>single index or list of indices of source processes
(default=&#8217;all&#8217;), if &#8216;all&#8217;, all possible sources for the given
target are tested</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results consisting of sets of selected variables as (full, from
sources only, from target only), pvalues and TE for each
significant source variable, the current value for this
analysis, results for omnibus test (joint influence of all
selected source variables on the target, omnibus TE, p-value,
and significance); NOTE that all variables are listed as tuples
(process, lag wrt. current value)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.multivariate_te">
<span id="idtxl-multivariate-te-module"></span><h2>idtxl.multivariate_te module<a class="headerlink" href="#module-idtxl.multivariate_te" title="Permalink to this headline">¶</a></h2>
<p>Estimate multivarate TE.</p>
<p>Created on Thu Mar 10 14:24:31 2016</p>
<p>Iterative greedy algorithm for multivariate network inference using transfer
entropy. For details see Lizier 2012 and Faes 2011.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.multivariate_te.MultivariateTE">
<em class="property">class </em><code class="descclassname">idtxl.multivariate_te.</code><code class="descname">MultivariateTE</code><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_inference.NetworkInference" title="idtxl.network_inference.NetworkInference"><code class="xref py py-class docutils literal"><span class="pre">idtxl.network_inference.NetworkInference</span></code></a></p>
<p>Perform network inference using multivariate transfer entropy.</p>
<p>Perform network inference using multivariate transfer entropy (TE). To
perform network inference call analyse_network() on the whole network or a
set of nodes or call analyse_single_target() to estimate TE for a single
target. See docstrings of the two functions for more information.</p>
<p>References:</p>
<blockquote>
<div><ul class="simple">
<li>Schreiber, T. (2000). Measuring Information Transfer. Phys Rev Lett,
85(2), 461–464. <a class="reference external" href="http://doi.org/10.1103/PhysRevLett.85.461">http://doi.org/10.1103/PhysRevLett.85.461</a></li>
<li>Vicente, R., Wibral, M., Lindner, M., &amp; Pipa, G. (2011). Transfer
entropy-a model-free measure of effective connectivity for the
neurosciences. J Comp Neurosci, 30(1), 45–67.
<a class="reference external" href="http://doi.org/10.1007/s10827-010-0262-3">http://doi.org/10.1007/s10827-010-0262-3</a></li>
<li>Lizier, J. T., &amp; Rubinov, M. (2012). Multivariate construction of
effective computational networks from observational data. Max Planck
Institute: Preprint. Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a></li>
<li>Faes, L., Nollo, G., &amp; Porta, A. (2011). Information-based detection
of nonlinear Granger causality in multivariate processes via a
nonuniform embedding technique. Phys Rev E, 83, 1–15.
<a class="reference external" href="http://doi.org/10.1103/PhysRevE.83.051112">http://doi.org/10.1103/PhysRevE.83.051112</a></li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>source_set <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>indices of source processes tested for their influence on the
target</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>index of target process</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>analysis settings</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value in TE estimation, (idx process,
idx sample)</dd>
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>samples in the full conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_sources <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>source samples in the conditional set, (idx process, idx sample)</dd>
<dt>selected_vars_target <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>target samples in the conditional set, (idx process, idx sample)</dd>
<dt>pvalue_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>p-value of the omnibus test</dd>
<dt>pvalues_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>array of p-values for TE from individual sources to the target</dd>
<dt>te_omnibus <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>joint TE from all sources to the target</dd>
<dt>te_sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd>raw TE values from individual sources to the target</dd>
<dt>sign_ominbus <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>statistical significance of the over-all TE</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.multivariate_te.MultivariateTE.analyse_network">
<code class="descname">analyse_network</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>targets='all'</em>, <em>sources='all'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between all nodes in the network.</p>
<p>Estimate multivariate transfer entropy (TE) between all nodes in the
network or between selected sources and targets.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>For a detailed description see the documentation of the
analyse_single_target() method of this class and the references.</dd>
</dl>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">dat</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, settings
can further contain</p>
<ul class="last simple">
<li>&#8216;verbose&#8217; : bool [optional] - toggle console output
(default=True)</li>
<li>&#8216;fdr_correction&#8217; : bool [optional] - correct results on the
network level, see documentation of stats.network_fdr() for
details (default=True)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">list of int | &#8216;all&#8217; [optional]</span></dt>
<dd>index of target processes (default=&#8217;all&#8217;)</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | list of list | &#8216;all&#8217; [optional]</span></dt>
<dd>indices of source processes for each target (default=&#8217;all&#8217;);
if &#8216;all&#8217;, all network nodes excluding the target node are
considered as potential sources and tested;
if list of int, the source specified by each int is tested as
a potential source for the target with the same index or a
single target;
if list of list, sources specified in each inner list are
tested for the target with the same index</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results for each target, see documentation of
analyse_single_target(); results FDR-corrected, see
documentation of stats.network_fdr()</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.multivariate_te.MultivariateTE.analyse_single_target">
<code class="descname">analyse_single_target</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>target</em>, <em>sources='all'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/multivariate_te.html#MultivariateTE.analyse_single_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.multivariate_te.MultivariateTE.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Find multivariate transfer entropy between sources and a target.</p>
<p>Find multivariate transfer entropy (TE) between all source processes
and the target process. Uses multivariate, non-uniform embedding found
through information maximisation (see Faes et al., 2011, Phys Rev E 83,
051112 and Lizier &amp; Rubinov, 2012, Max Planck Institute: Preprint.
Retrieved from
<a class="reference external" href="http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf">http://www.mis.mpg.de/preprints/2012/preprint2012_25.pdf</a>). Multivariate
TE is calculated in four steps (see Lizier and Faes for details):</p>
<ol class="arabic simple">
<li>find all relevant samples in the target processes&#8217; own past, by
iteratively adding candidate samples that have significant
conditional mutual information (CMI) with the current value
(conditional on all samples that were added previously)</li>
<li>find all relevant samples in the source processes&#8217; pasts (again
by finding all candidates with significant CMI)</li>
<li>prune the final conditional set by testing the CMI between each
sample in the final set and the current value, conditional on all
other samples in the final set</li>
<li>statistics on the final set of sources (test for over-all transfer
between the final conditional set and the current value, and for
significant transfer of all individual samples in the set)</li>
</ol>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span><span class="o">.</span><span class="n">generate_mute_data</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;cmi_estimator&#39;</span><span class="p">:</span>  <span class="s1">&#39;JidtKraskovCMI&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_lag_sources&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;min_lag_sources&#39;</span><span class="p">:</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">network_analysis</span> <span class="o">=</span> <span class="n">MultivariateTE</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">network_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">dat</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                             <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimation and statistical testing:</p>
<ul class="last simple">
<li>&#8216;cmi_estimator&#8217; : str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</li>
<li>&#8216;max_lag_sources&#8217; : int - maximum temporal search depth for
candidates in the sources&#8217; past in samples</li>
<li>&#8216;min_lag_sources&#8217; : int - minimum temporal search depth for
candidates in the sources&#8217; past in samples</li>
<li>&#8216;max_lag_target&#8217; : int [optional] - maximum temporal search
depth for candidates in the target&#8217;s past in samples
(default=same as max_lag_sources)</li>
<li>&#8216;tau_sources&#8217; : int [optional] - spacing between candidates in
the sources&#8217; past in samples (default=1)</li>
<li>&#8216;tau_target&#8217; : int [optional] - spacing between candidates in
the target&#8217;s past in samples (default=1)</li>
<li>&#8216;n_perm_*&#8217; : int [optional] - number of permutations, where *
can be &#8216;max_stat&#8217;, &#8216;min_stat&#8217;, &#8216;omnibus&#8217;, and &#8216;max_seq&#8217;
(default=500)</li>
<li>&#8216;alpha_*&#8217; : float [optional] - critical alpha level for
statistical significance, where * can be &#8216;max_stats&#8217;,
&#8216;min_stats&#8217;, &#8216;omnibus&#8217;, and &#8216;max_seq&#8217; (default=0.05)</li>
<li>&#8216;add_conditionals&#8217; : list of tuples | str [optional] - force
the estimator to add these conditionals when estimating TE;
can either be a list of variables, where each variable is
described as (idx process, lag wrt to current value) or can
be a string: &#8216;faes&#8217; for Faes-Method (see references)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - force surrogate
creation by shuffling realisations in time instead of
shuffling replications; see documentation of
Data.permute_samples() for further settings (default=False)</li>
<li>&#8216;verbose&#8217; : bool [optional] - toggle console output
(default=True)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of target process</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of int | int | &#8216;all&#8217; [optional]</span></dt>
<dd>single index or list of indices of source processes
(default=&#8217;all&#8217;), if &#8216;all&#8217;, all network nodes excluding the
target node are considered as potential sources</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results consisting of sets of selected variables as (full set,
variables from the sources&#8217; past, variables from the target&#8217;s
past), pvalues and TE for each selected variable, the current
value for this analysis, results for omnibus test (joint
influence of all selected source variables on the target,
omnibus TE, p-value, and significance); NOTE that all variables
are listed as tuples (process, lag wrt. current value)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.network_analysis">
<span id="idtxl-network-analysis-module"></span><h2>idtxl.network_analysis module<a class="headerlink" href="#module-idtxl.network_analysis" title="Permalink to this headline">¶</a></h2>
<p>Parent class for network inference and network comparison.</p>
<p>Created on Mon Mar  7 18:13:27 2016</p>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.network_analysis.NetworkAnalysis">
<em class="property">class </em><code class="descclassname">idtxl.network_analysis.</code><code class="descname">NetworkAnalysis</code><a class="reference internal" href="_modules/idtxl/network_analysis.html#NetworkAnalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Provide an analysis setup for network inference or comparison.</p>
<p>The class provides routines to check user input and set defaults.</p>
<dl class="attribute">
<dt id="idtxl.network_analysis.NetworkAnalysis.current_value">
<code class="descname">current_value</code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.current_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get index of the current_value.</p>
</dd></dl>

<dl class="attribute">
<dt id="idtxl.network_analysis.NetworkAnalysis.selected_vars_full">
<code class="descname">selected_vars_full</code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_full" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of the full conditional set.</p>
</dd></dl>

<dl class="attribute">
<dt id="idtxl.network_analysis.NetworkAnalysis.selected_vars_sources">
<code class="descname">selected_vars_sources</code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_sources" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of source samples in the conditional set.</p>
</dd></dl>

<dl class="attribute">
<dt id="idtxl.network_analysis.NetworkAnalysis.selected_vars_target">
<code class="descname">selected_vars_target</code><a class="headerlink" href="#idtxl.network_analysis.NetworkAnalysis.selected_vars_target" title="Permalink to this definition">¶</a></dt>
<dd><p>List of indices of target samples in the conditional set.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.network_comparison">
<span id="idtxl-network-comparison-module"></span><h2>idtxl.network_comparison module<a class="headerlink" href="#module-idtxl.network_comparison" title="Permalink to this headline">¶</a></h2>
<p>Perform inference statistics on groups of data.</p>
<dl class="class">
<dt id="idtxl.network_comparison.NetworkComparison">
<em class="property">class </em><code class="descclassname">idtxl.network_comparison.</code><code class="descname">NetworkComparison</code><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
<p>Set up network comparison between two experimental conditions.</p>
<p>The class provides methods for the comparison of networks inferred from
data recorded under two experimental conditions. Four statistical tests
are implemented:</p>
<div class="line-block">
<div class="line">| stats_type | example                             |</div>
</div>
<p><a href="#id9"><span class="problematic" id="id10">|&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-|</span></a>&#8212;&#8212;&#8212;&#8212;<a href="#id11"><span class="problematic" id="id12">|&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-|</span></a>
| __within__ subjects  <a href="#id13"><span class="problematic" id="id14">|dependent   |base line (A) vs. task (B)           |
|                      |independent |detect house (A) vs. face (B)        |
| __between__ subjects |dependent   |patients (A) vs. matched controls (B)|</span></a>
|                      <a href="#id3"><span class="problematic" id="id4">|</span></a>independent <a href="#id5"><span class="problematic" id="id6">|</span></a>male (A) vs. female (B) participants |</p>
<p>There are two methods for within and between comparisons: compare_within()
and compare_between(). The stats_type is passed as an analysis option, see
the documentation of the two classes for details.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>union <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>union of all networks entering the comparison, used as the basis
for statistical comparison</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>parameters for CMI estimation</dd>
<dt>cmi_diff <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>original difference in CMI estimates for each source variable &gt;
target combination in the union network</dd>
<dt>cmi_surr <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>differences in CMI estimates from surrogate data, used as test
distribution</dd>
<dt>alpha <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>critical alpha level for network comparison</dd>
<dt>n_permutations <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of permutations</dd>
<dt>stats_type <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>type of statistics (&#8216;dependent&#8217; or &#8216;independent&#8217;)</dd>
<dt>tail <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>test tail (&#8216;one&#8217; or &#8216;two&#8217;)</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.network_comparison.NetworkComparison.compare_between">
<code class="descname">compare_between</code><span class="sig-paren">(</span><em>settings</em>, <em>network_set_a</em>, <em>network_set_b</em>, <em>data_set_a</em>, <em>data_set_b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_between"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_between" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare networks inferred under two conditions between subjects.</p>
<p>Compare two sets of networks inferred from two sets of data recorded
under different experimental conditions within multiple subjects, i.e.,
data have been recorded from subjects assigned to one of two
experimental conditions (units of observations are subjects).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>parameters for estimation and statistical testing, see
documentation of compare_within() for details</dd>
<dt>network_set_a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of dicts</span></dt>
<dd>results from network inference for multiple subjects observed
under condition a</dd>
<dt>network_set_b <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of dicts</span></dt>
<dd>results from network inference for multiple subjects observed
under condition b</dd>
<dt>data_a <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of Data objects</span></dt>
<dd>set of data from which network_set_a was inferred</dd>
<dt>data_b <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of Data objects</span></dt>
<dd>set of data from which network_set_b was inferred</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results of network comparison, contains the union network
(&#8216;union_network&#8217;), parameters used for statistical comparison
(critical alpha level, &#8216;alpha&#8217;; number of permutations,
&#8216;n_permutations&#8217;; statistics type, &#8216;stats_type&#8217;, test tail,
&#8216;tail&#8217;), parameters used for CMI estimation (&#8216;settings&#8217;),
the original CMI difference (&#8216;cmi_diff&#8217;), the surrogate CMI
values (&#8216;cmi_surr&#8217;), the p-value for each source variable &gt;
target combination in the union network (&#8216;pval&#8217;) and their
statistical significance (&#8216;sign&#8217;)</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.network_comparison.NetworkComparison.compare_within">
<code class="descname">compare_within</code><span class="sig-paren">(</span><em>settings</em>, <em>network_a</em>, <em>network_b</em>, <em>data_a</em>, <em>data_b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/network_comparison.html#NetworkComparison.compare_within"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_comparison.NetworkComparison.compare_within" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare networks inferred under two conditions within one subject.</p>
<p>Compare two networks inferred from data recorded under two different
experimental conditions within one subject (units of observations are
replications of one experimental condition within one subject).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimation and statistical testing</p>
<ul class="last simple">
<li>&#8216;stats_type&#8217; str - &#8216;dependent&#8217; or &#8216;independent&#8217; for
dependent or independent units of observation</li>
<li>&#8216;cmi_estimator&#8217; str - estimator to be used for CMI
calculation (for estimator settings see the documentation in
the estimators_* modules)</li>
<li>&#8216;tail_comp&#8217; str [optional] - test tail, &#8216;one&#8217; for one-sided
test, &#8216;two&#8217; for two-sided test (default=&#8217;two&#8217;)</li>
<li>&#8216;n_perm_comp&#8217; int [optional] - number of permutations
(default=500)</li>
<li>&#8216;alpha_comp&#8217; float - critical alpha level for statistical
significance (default=0.05)</li>
</ul>
</dd>
<dt>network_a <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>results from network inference, condition a</dd>
<dt>network_b <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>results from network inference, condition b</dd>
<dt>data_a <span class="classifier-delimiter">:</span> <span class="classifier">Data object</span></dt>
<dd>data from which network_a was inferred</dd>
<dt>data_b <span class="classifier-delimiter">:</span> <span class="classifier">Data object</span></dt>
<dd>data from which network_b was inferred</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results of network comparison, contains the union network
(&#8216;union_network&#8217;), parameters used for statistical comparison
(critical alpha level, &#8216;alpha&#8217;; number of permutations,
&#8216;n_permutations&#8217;; statistics type, &#8216;stats_type&#8217;, test tail,
&#8216;tail&#8217;), parameters used for CMI estimation (&#8216;settings&#8217;),
the original CMI difference (&#8216;cmi_diff&#8217;), the surrogate CMI
values (&#8216;cmi_surr&#8217;), the p-value for each source variable &gt;
target combination in the union network (&#8216;pval&#8217;) and their
statistical significance (&#8216;sign&#8217;)</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.network_inference">
<span id="idtxl-network-inference-module"></span><h2>idtxl.network_inference module<a class="headerlink" href="#module-idtxl.network_inference" title="Permalink to this headline">¶</a></h2>
<p>Parent class for all network inference.</p>
<p>Created on Mon Mar  7 18:13:27 2016</p>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.network_inference.NetworkInference">
<em class="property">class </em><code class="descclassname">idtxl.network_inference.</code><code class="descname">NetworkInference</code><a class="reference internal" href="_modules/idtxl/network_inference.html#NetworkInference"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.network_inference.NetworkInference" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
<p>Parent class for network inference algorithms.</p>
<p>Hold variables that are relevant for network inference using for example
bivariate and multivariate transfer entropy.</p>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>settings for estimation of information theoretic measures and
statistical testing, see child classes for documentation</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>target process of analysis</dd>
<dt>current_value <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>index of the current value</dd>
<dt>selected_vars_full <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of the full set of random variables to be conditioned on</dd>
<dt>selected_vars_target <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of the set of conditionals coming from the target process</dd>
<dt>selected_vars_sources <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>indices of the set of conditionals coming from source processes</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.partial_information_decomposition">
<span id="idtxl-partial-information-decomposition-module"></span><h2>idtxl.partial_information_decomposition module<a class="headerlink" href="#module-idtxl.partial_information_decomposition" title="Permalink to this headline">¶</a></h2>
<p>Estimate partial information decomposition (PID).</p>
<p>Estimate PID for two source and one target process using different estimators.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>Written for Python 3.4+</dd>
</dl>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.partial_information_decomposition.PartialInformationDecomposition">
<em class="property">class </em><code class="descclassname">idtxl.partial_information_decomposition.</code><code class="descname">PartialInformationDecomposition</code><a class="reference internal" href="_modules/idtxl/partial_information_decomposition.html#PartialInformationDecomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.partial_information_decomposition.PartialInformationDecomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="idtxl.single_process_analysis.SingleProcessAnalysis"><code class="xref py py-class docutils literal"><span class="pre">idtxl.single_process_analysis.SingleProcessAnalysis</span></code></a></p>
<p>Perform partial information decomposition for individual processes.</p>
<p>Perform partial information decomposition (PID) for two source processes
and one target process in the network. Estimate unique, shared, and
synergistic information in the two sources about the target. Call
analyse_network() on the whole network or a set of nodes or call
analyse_single_target() to estimate PID for a single process. See
docstrings of the two functions for more information.</p>
<p>References:</p>
<blockquote>
<div><ul class="simple">
<li>Williams, P. L., &amp; Beer, R. D. (2010). Nonnegative Decomposition of
Multivariate Information, 1–14. Retrieved from
<a class="reference external" href="http://arxiv.org/abs/1004.2515">http://arxiv.org/abs/1004.2515</a></li>
<li>Bertschinger, N., Rauh, J., Olbrich, E., Jost, J., &amp; Ay, N. (2014).
Quantifying Unique Information. Entropy, 16(4), 2161–2183.
<a class="reference external" href="http://doi.org/10.3390/e16042161">http://doi.org/10.3390/e16042161</a></li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Attributes:</dt>
<dd><dl class="first last docutils">
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of target process</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">array type</span></dt>
<dd>pair of indices of source processes</dd>
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>analysis settings</dd>
<dt>results <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>estimated PID</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="idtxl.partial_information_decomposition.PartialInformationDecomposition.analyse_network">
<code class="descname">analyse_network</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>targets</em>, <em>sources</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/partial_information_decomposition.html#PartialInformationDecomposition.analyse_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.partial_information_decomposition.PartialInformationDecomposition.analyse_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for network nodes.</p>
<p>Estimate partial information decomposition (PID) for multiple nodes in
the network.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>For a detailed description and references see the documentation of
the analyse_single_target() method of this class.</dd>
</dl>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_calc_name&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lags</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">PartialInformationDecomposition</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_network</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">dat</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                   <span class="n">sources</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimation and statistical testing, see
documentation of analyse_single_target() for details, can
contain</p>
<ul class="last simple">
<li>&#8216;lags&#8217; : list of lists of ints [optional] - lags in samples
between sources and target (default=[[1, 1], [1, 1] ...])</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>targets <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd>index of target processes</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of lists</span></dt>
<dd>indices of the two source processes for each target, e.g.,
[[0, 2], [1, 0]], must have the same length as targets</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>results for each process, see documentation of
analyse_single_target()</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="idtxl.partial_information_decomposition.PartialInformationDecomposition.analyse_single_target">
<code class="descname">analyse_single_target</code><span class="sig-paren">(</span><em>settings</em>, <em>data</em>, <em>target</em>, <em>sources</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/partial_information_decomposition.html#PartialInformationDecomposition.analyse_single_target"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.partial_information_decomposition.PartialInformationDecomposition.analyse_single_target" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate partial information decomposition for a network node.</p>
<p>Estimate partial information decomposition (PID) for a target node in
the network.</p>
<p># TODO add references</p>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alph</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alph</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dat</span> <span class="o">=</span> <span class="n">Data</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)),</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="n">normalise</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">settings</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s1&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_s2&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;alph_t&#39;</span><span class="p">:</span> <span class="n">alph</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_unsuc_swaps_row_parm&#39;</span><span class="p">:</span> <span class="mi">60</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;num_reps&#39;</span><span class="p">:</span> <span class="mi">63</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;max_iters&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;pid_calc_name&#39;</span><span class="p">:</span> <span class="s1">&#39;SydneyPID&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="s1">&#39;lags&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pid_analysis</span> <span class="o">=</span> <span class="n">PartialInformationDecomposition</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">pid_analysis</span><span class="o">.</span><span class="n">analyse_single_target</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="n">settings</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                         <span class="n">data</span><span class="o">=</span><span class="n">dat</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                         <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                         <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">parameters for estimator use and statistics:</p>
<ul class="last simple">
<li>&#8216;pid_estimator&#8217; : str - estimator to be used for PID
estimation (for estimator settings see the documentation in
the estimators_pid modules)</li>
<li>&#8216;lags&#8217; : list of ints [optional] - lags in samples between
sources and target (default=[1, 1])</li>
<li>&#8216;verbose&#8217; : bool [optional] - toggle console output
(default=True)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data for analysis</dd>
<dt>target <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>index of target processes</dd>
<dt>sources <span class="classifier-delimiter">:</span> <span class="classifier">list of ints</span></dt>
<dd>indices of the two source processes for the target</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>unique, shared and synergistic information from both sources,
statistical significance and p-values, indices of source
variables, and settings used for estimation</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-idtxl.single_process_analysis">
<span id="idtxl-single-process-analysis-module"></span><h2>idtxl.single_process_analysis module<a class="headerlink" href="#module-idtxl.single_process_analysis" title="Permalink to this headline">¶</a></h2>
<p>Parent class for analysis of single processes in the network.</p>
<p>&#64;author: patricia</p>
<dl class="class">
<dt id="idtxl.single_process_analysis.SingleProcessAnalysis">
<em class="property">class </em><code class="descclassname">idtxl.single_process_analysis.</code><code class="descname">SingleProcessAnalysis</code><a class="reference internal" href="_modules/idtxl/single_process_analysis.html#SingleProcessAnalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.single_process_analysis.SingleProcessAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#idtxl.network_analysis.NetworkAnalysis" title="idtxl.network_analysis.NetworkAnalysis"><code class="xref py py-class docutils literal"><span class="pre">idtxl.network_analysis.NetworkAnalysis</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-idtxl.stats">
<span id="idtxl-stats-module"></span><h2>idtxl.stats module<a class="headerlink" href="#module-idtxl.stats" title="Permalink to this headline">¶</a></h2>
<p>Provide statistics functions.</p>
<p>Created on Mon Mar  7 18:13:27 2016</p>
<p>&#64;author: patricia</p>
<dl class="function">
<dt id="idtxl.stats.check_n_perm">
<code class="descclassname">idtxl.stats.</code><code class="descname">check_n_perm</code><span class="sig-paren">(</span><em>n_perm</em>, <em>alpha</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#check_n_perm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.check_n_perm" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if no. permutations is big enough to obtain the requested alpha.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd>The no. permutations must be big enough to theoretically allow for the
detection of a p-value that is smaller than the critical alpha level.
Otherwise the permutation test is pointless. The smalles possible
p-value is 1/n_perm.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.max_statistic">
<code class="descclassname">idtxl.stats.</code><code class="descname">max_statistic</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em>, <em>candidate_set</em>, <em>te_max_candidate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.max_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform maximum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the maximum
values obtained from surrogates of all remanining candidates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
&#8216;settings&#8217;, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>&#8216;n_perm_max_stat&#8217; : int [optional] - number of permutations
(default=200)</li>
<li>&#8216;alpha_max_stat&#8217; : float [optional] - critical alpha level
(default=0.05)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>candidate_set <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>list of indices of remaning candidates</dd>
<dt>te_max_candidate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transfer entropy value to be tested</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test&#8217;s p-value</dd>
<dt>numpy array</dt>
<dd>surrogate table</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.max_statistic_sequential">
<code class="descclassname">idtxl.stats.</code><code class="descname">max_statistic_sequential</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#max_statistic_sequential"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.max_statistic_sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform sequential maximum statistics for a set of candidate sources.</p>
<p>Test if sorted transfer entropy (TE) values are significantly bigger than
their respective counterpart obtained from surrogates of all remanining
candidates: test if the biggest TE is bigger than the distribution
of biggest TE surrogate values; test if the 2nd biggest TE is bigger than
the distribution of 2nd biggest surrogate TE values; ...
Stop comparison if a TE value is non significant, all smaller values are
considered non-significant as well.</p>
<p>This function will re-use the surrogate table created in the last min-stats
round if that table is in the analysis_setup. This saves the complete
calculation of surrogates for this statistic.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
&#8216;settings&#8217;, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>&#8216;n_perm_max_seq&#8217; : int [optional] - number of permutations
(default=&#8217;n_perm_min_stat&#8217;<a href="#id7"><span class="problematic" id="id8">|</span></a>500)</li>
<li>&#8216;alpha_max_seq&#8217; : float [optional] - critical alpha level
(default=0.05)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array, bool</dt>
<dd>statistical significance of each source</dd>
<dt>numpy array, float</dt>
<dd>the test&#8217;s p-values for each source</dd>
<dt>numpy array, float</dt>
<dd>TE values for individual sources</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.mi_against_surrogates">
<code class="descclassname">idtxl.stats.</code><code class="descname">mi_against_surrogates</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#mi_against_surrogates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.mi_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test estimated mutual information for significance against surrogate data.</p>
<p>Shuffle realisations of the current value (point to be predicted) and re-
calculate mutual information (MI) for shuffled data. The actual estimated
MI is then compared against this distribution of MI values from surrogate
data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
&#8216;settings&#8217;, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>&#8216;n_perm_mi&#8217; : int [optional] - number of permutations
(default=500)</li>
<li>&#8216;alpha_mi&#8217; : float [optional] - critical alpha level
(default=0.05)</li>
<li>&#8216;tail_mi&#8217; : str [optional] - tail for testing, can be &#8216;one&#8217; or
&#8216;two&#8217; (default=&#8217;one&#8217;)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>float</dt>
<dd>estimated MI value</dd>
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>p_value for estimated MI value</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.min_statistic">
<code class="descclassname">idtxl.stats.</code><code class="descname">min_statistic</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em>, <em>candidate_set</em>, <em>te_min_candidate</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#min_statistic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.min_statistic" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform minimum statistics for one candidate source.</p>
<p>Test if a transfer entropy value is significantly bigger than the minimum
values obtained from surrogates of all remanining candidates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
&#8216;settings&#8217;, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>&#8216;n_perm_min_stat&#8217; - number of permutations (default=500)</li>
<li>&#8216;alpha_min_stat&#8217; - critical alpha level (default=0.05)</li>
<li>&#8216;permute_in_time&#8217; bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
<dt>candidate_set <span class="classifier-delimiter">:</span> <span class="classifier">list of tuples</span></dt>
<dd>list of indices of remaning candidates</dd>
<dt>te_min_candidate <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>transfer entropy value to be tested</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test&#8217;s p-value</dd>
<dt>numpy array</dt>
<dd>surrogate table</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.network_fdr">
<code class="descclassname">idtxl.stats.</code><code class="descname">network_fdr</code><span class="sig-paren">(</span><em>settings=None</em>, <em>*results</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#network_fdr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.network_fdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform FDR-correction on results of network inference.</p>
<p>Perform correction of the false discovery rate (FDR) after network
analysis. FDR correction can either be applied at the target level
(by correcting omnibus p-values) or at the single-link level (by correcting
p-values of individual links between single samples and the target).</p>
<p>Input can be a list of partial results to combine results from parallel
analysis.</p>
<p>References:</p>
<blockquote>
<div><ul class="simple">
<li>Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of
statistical maps in functional neuroimaging using the false discovery
rate. Neuroimage, 15(4), 870-878.</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings <span class="classifier-delimiter">:</span> <span class="classifier">dict [optional]</span></dt>
<dd><p class="first">parameters for statistical testing with entries:</p>
<ul class="last simple">
<li>&#8216;alpha_fdr&#8217; : float [optional] - critical alpha level
(default=0.05)</li>
<li>&#8216;correct_by_target&#8217; : bool [optional] - if true p-values are
corrected on the target level and on the single-link level
otherwise (default=True)</li>
</ul>
</dd>
<dt>results <span class="classifier-delimiter">:</span> <span class="classifier">list of dicts</span></dt>
<dd>network inference results from .analyse_network methods, where each
dict entry represents results for one target node</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>input results structure pruned of non-significant links.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.omnibus_test">
<code class="descclassname">idtxl.stats.</code><code class="descname">omnibus_test</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#omnibus_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.omnibus_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform an omnibus test on identified conditional variables.</p>
<p>Test the joint information transfer from all identified sources to the
current value conditional on candidates in the target&#8217;s past. To test for
significance, this is repeated for shuffled realisations of the sources.
The distribution of values from shuffled data is then used as test
distribution.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">MultivariateTE instance</span></dt>
<dd><p class="first">information on the current analysis, can have an optional attribute
&#8216;settings&#8217;, a dictionary with parameters for statistical testing:</p>
<ul class="last simple">
<li>&#8216;n_perm_omnibus&#8217; : int [optional] - number of permutations
(default=500)</li>
<li>&#8216;alpha_omnibus&#8217; : float [optional] - critical alpha level
(default=0.05)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool</dt>
<dd>statistical significance</dd>
<dt>float</dt>
<dd>the test&#8217;s p-value</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.syn_shd_against_surrogates">
<code class="descclassname">idtxl.stats.</code><code class="descname">syn_shd_against_surrogates</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#syn_shd_against_surrogates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.syn_shd_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the shared/synergistic information in the PID estimate.</p>
<p>Shuffle realisations of the target and re-calculate PID, in particular the
synergistic and shared information from shuffled data. The original
shared and synergistic information are then compared against the
distribution of values calculated from surrogate data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Partial_information_decomposition instance</span></dt>
<dd><p class="first">information on the current analysis, should have an Attribute
&#8216;settings&#8217;, a dict with optional fields</p>
<ul class="last simple">
<li>&#8216;n_perm&#8217; : int [optional] - number of permutations (default=500)</li>
<li>&#8216;alpha&#8217; : float [optional] - critical alpha level (default=0.05)</li>
<li>&#8216;tail&#8217; : str [optional] - tail for testing, can be &#8216;one&#8217; or &#8216;two&#8217;
(default=&#8217;one&#8217;)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>PID estimate from original data</dd>
<dt>bool</dt>
<dd>statistical significance of the shared information</dd>
<dt>float</dt>
<dd>p-value of the shared information</dd>
<dt>bool</dt>
<dd>statistical significance of the synergistic information</dd>
<dt>float</dt>
<dd>p-value of the synergistic information</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.stats.unq_against_surrogates">
<code class="descclassname">idtxl.stats.</code><code class="descname">unq_against_surrogates</code><span class="sig-paren">(</span><em>analysis_setup</em>, <em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/stats.html#unq_against_surrogates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.stats.unq_against_surrogates" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the unique information in the PID estimate against surrogate data.</p>
<p>Shuffle realisations of both sources individually and re-calculate PID,
in particular the unique information from shuffled data. The original
unique information is then compared against the distribution of values
calculated from surrogate data.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>analysis_setup <span class="classifier-delimiter">:</span> <span class="classifier">Partial_information_decomposition instance</span></dt>
<dd><p class="first">information on the current analysis, should have an Attribute
&#8216;settings&#8217;, a dict with optional fields</p>
<ul class="last simple">
<li>&#8216;n_perm&#8217; - number of permutations (default=500)</li>
<li>&#8216;alpha&#8217; - critical alpha level (default=0.05)</li>
<li>&#8216;tail&#8217; - tail for testing, can be &#8216;one&#8217; or &#8216;two&#8217;
(default=&#8217;one&#8217;)</li>
<li>&#8216;permute_in_time&#8217; : bool [optional] - generate surrogates by
shuffling samples in time instead of shuffling whole replications
(default=False)</li>
</ul>
</dd>
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data instance</span></dt>
<dd>raw data</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>dict</dt>
<dd>PID estimate from original data</dd>
<dt>bool</dt>
<dd>statistical significance of the unique information in source 1</dd>
<dt>float</dt>
<dd>p-value of the unique information in source 1</dd>
<dt>bool</dt>
<dd>statistical significance of the unique information in source 2</dd>
<dt>float</dt>
<dd>p-value of the unique information in source 2</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl.synergy_tartu">
<span id="idtxl-synergy-tartu-module"></span><h2>idtxl.synergy_tartu module<a class="headerlink" href="#module-idtxl.synergy_tartu" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="idtxl.synergy_tartu.Compute_UI">
<em class="property">class </em><code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">Compute_UI</code><span class="sig-paren">(</span><em>marg_xy</em>, <em>marg_xz</em>, <em>_set_to_zero=set()</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="class">
<dt id="idtxl.synergy_tartu.Compute_UI.KKT_System">
<em class="property">class </em><code class="descname">KKT_System</code><span class="sig-paren">(</span><em>cui</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.KKT_System"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.KKT_System" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.KKT_System.solve">
<code class="descname">solve</code><span class="sig-paren">(</span><em>p</em>, <em>ZERO=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.KKT_System.solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.KKT_System.solve" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.callback">
<code class="descclassname">Compute_UI.</code><code class="descname">callback</code><span class="sig-paren">(</span><em>p=None</em>, <em>zz=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.callback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.check_KKT_sol">
<code class="descclassname">Compute_UI.</code><code class="descname">check_KKT_sol</code><span class="sig-paren">(</span><em>p</em>, <em>why</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.check_KKT_sol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.check_KKT_sol" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.check_feasible">
<code class="descclassname">Compute_UI.</code><code class="descname">check_feasible</code><span class="sig-paren">(</span><em>p</em>, <em>use_cleaned_up_margs=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.check_feasible"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.check_feasible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.check_guess">
<code class="descclassname">Compute_UI.</code><code class="descname">check_guess</code><span class="sig-paren">(</span><em>p</em>, <em>y=None</em>, <em>kkt_filename=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.check_guess"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.check_guess" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.create_equations">
<code class="descclassname">Compute_UI.</code><code class="descname">create_equations</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.create_equations"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.create_equations" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.create_ieqs">
<code class="descclassname">Compute_UI.</code><code class="descname">create_ieqs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.create_ieqs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.create_ieqs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.make_KKT_lp">
<code class="descclassname">Compute_UI.</code><code class="descname">make_KKT_lp</code><span class="sig-paren">(</span><em>p</em>, <em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.make_KKT_lp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.make_KKT_lp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.make_initial_solution">
<code class="descclassname">Compute_UI.</code><code class="descname">make_initial_solution</code><span class="sig-paren">(</span><em>orig_q_0=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.make_initial_solution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.make_initial_solution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.options">
<code class="descclassname">Compute_UI.</code><code class="descname">options</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.options" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.search_for_kkt_solution">
<code class="descclassname">Compute_UI.</code><code class="descname">search_for_kkt_solution</code><span class="sig-paren">(</span><em>p</em>, <em>stop_search_kkt_eps=-1.0</em>, <em>stop_search_prob_eps=1.0</em>, <em>show_progress=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.search_for_kkt_solution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.search_for_kkt_solution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.solve_KKT_system">
<code class="descclassname">Compute_UI.</code><code class="descname">solve_KKT_system</code><span class="sig-paren">(</span><em>p</em>, <em>ZERO=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.solve_KKT_system"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.solve_KKT_system" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.solve_it">
<code class="descclassname">Compute_UI.</code><code class="descname">solve_it</code><span class="sig-paren">(</span><em>_eps=1e-10</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.solve_it"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.solve_it" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.tidy_up_distrib">
<code class="descclassname">Compute_UI.</code><code class="descname">tidy_up_distrib</code><span class="sig-paren">(</span><em>p</em>, <em>eps</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.tidy_up_distrib"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.tidy_up_distrib" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="idtxl.synergy_tartu.Compute_UI.try_to_improve_by_LP">
<code class="descclassname">Compute_UI.</code><code class="descname">try_to_improve_by_LP</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#Compute_UI.try_to_improve_by_LP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.Compute_UI.try_to_improve_by_LP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.I_X_Y">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">I_X_Y</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#I_X_Y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.I_X_Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.I_X_YZ">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">I_X_YZ</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#I_X_YZ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.I_X_YZ" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.cond_I_X_Y__Z">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">cond_I_X_Y__Z</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#cond_I_X_Y__Z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.cond_I_X_Y__Z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.cond_I_X_Z__Y">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">cond_I_X_Z__Y</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#cond_I_X_Z__Y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.cond_I_X_Z__Y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.gradient">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">gradient</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.gradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.kl_divergence">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">kl_divergence</code><span class="sig-paren">(</span><em>Of</em>, <em>From</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#kl_divergence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.kl_divergence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.marginal_x">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">marginal_x</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#marginal_x"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.marginal_x" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.marginal_xy">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">marginal_xy</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#marginal_xy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.marginal_xy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.marginal_xz">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">marginal_xz</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#marginal_xz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.marginal_xz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.marginal_y">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">marginal_y</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#marginal_y"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.marginal_y" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.marginal_yz">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">marginal_yz</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#marginal_yz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.marginal_yz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.marginal_yz_with_cutoff">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">marginal_yz_with_cutoff</code><span class="sig-paren">(</span><em>p</em>, <em>ZERO=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#marginal_yz_with_cutoff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.marginal_yz_with_cutoff" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.marginal_z">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">marginal_z</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#marginal_z"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.marginal_z" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.print_solution_stats">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">print_solution_stats</code><span class="sig-paren">(</span><em>soliter</em>, <em>the_p</em>, <em>pdf</em>, <em>true_pdf</em>, <em>true_result</em>, <em>true_CI</em>, <em>true_SI</em>, <em>feas=None</em>, <em>kkt=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#print_solution_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.print_solution_stats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.solve_PDF">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">solve_PDF</code><span class="sig-paren">(</span><em>pdf</em>, <em>true_pdf=None</em>, <em>true_result=None</em>, <em>true_CI=None</em>, <em>true_SI=None</em>, <em>feas_eps=1e-10</em>, <em>kkt_eps=1e-05</em>, <em>feas_eps_2=1e-06</em>, <em>kkt_eps_2=0.01</em>, <em>kkt_search_eps=0.5</em>, <em>max_zero_probability=1e-05</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#solve_PDF"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.solve_PDF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.sorted_pdf">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">sorted_pdf</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#sorted_pdf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.sorted_pdf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.support_variation">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">support_variation</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#support_variation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.support_variation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.total_variation_distance">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">total_variation_distance</code><span class="sig-paren">(</span><em>P</em>, <em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#total_variation_distance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.total_variation_distance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.wriggle_CI">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">wriggle_CI</code><span class="sig-paren">(</span><em>p</em>, <em>q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#wriggle_CI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.wriggle_CI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="idtxl.synergy_tartu.wriggle_SI">
<code class="descclassname">idtxl.synergy_tartu.</code><code class="descname">wriggle_SI</code><span class="sig-paren">(</span><em>q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/synergy_tartu.html#wriggle_SI"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.synergy_tartu.wriggle_SI" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-idtxl.visualise_graph">
<span id="idtxl-visualise-graph-module"></span><h2>idtxl.visualise_graph module<a class="headerlink" href="#module-idtxl.visualise_graph" title="Permalink to this headline">¶</a></h2>
<p>Export and plot results as networkx objects.</p>
<dl class="function">
<dt id="idtxl.visualise_graph.generate_network_graph">
<code class="descclassname">idtxl.visualise_graph.</code><code class="descname">generate_network_graph</code><span class="sig-paren">(</span><em>res</em>, <em>n_nodes</em>, <em>fdr=True</em>, <em>find_u='max_te'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#generate_network_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.generate_network_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate graph object for an inferred network.</p>
<p>Generate a weighted, directed graph object from the network of inferred
(multivariate) interactions (e.g., multivariate TE), using the networkx
class for directed graphs (DiGraph). The graph is weighted by the
reconstructed source-target delays.</p>
<p>Source-target delays are determined by the lag of the variable in a
sources&#8217; past that has the highest information transfer into the target
process. There are two ways of idendifying the variable with maximum
information transfer:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>use the variable with the highest absolute TE value (highest
information transfer)</li>
<li>use the variable with the smallest p-value (highest statistical
significance)</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_network()</dd>
<dt>n_nodes <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of nodes in the network</dd>
<dt>fdr <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>print FDR-corrected results (default=True)</dd>
<dt>find_u <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>use TE value (&#8216;max_te&#8217;) or p-value (&#8216;max_p&#8217;) to determine the
variable with maximum information transfer into the target in order
to determine the source-target delay (default=&#8217;max_te&#8217;)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.generate_source_graph">
<code class="descclassname">idtxl.visualise_graph.</code><code class="descname">generate_source_graph</code><span class="sig-paren">(</span><em>res</em>, <em>sign_sources=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#generate_source_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.generate_source_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate graph object for a target process and single variables.</p>
<p>Generate a graph object from the network of (multivariate)
interactions (e.g., multivariate TE) between single samples and
a target sample (current value), using the networkx class for
directed graphs (DiGraph).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_single_target()</dd>
<dt>sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>add only sources significant information contribution
(default=True)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.plot_mute_graph">
<code class="descclassname">idtxl.visualise_graph.</code><code class="descname">plot_mute_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_mute_graph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_mute_graph" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot MuTE example network.</p>
<p>Network of 5 AR-processes, which is used as an example the paper
on the MuTE toolbox (Montalto, PLOS ONE, 2014, eq. 14). The
network consists of five autoregressive (AR) processes with model
orders 2 and les and the following (non-linear) couplings:</p>
<blockquote>
<div>0 -&gt; 1, u = 2
0 -&gt; 2, u = 3
0 -&gt; 3, u = 2 (non-linear)
3 -&gt; 4, u = 1
4 -&gt; 3, u = 1</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.plot_network">
<code class="descclassname">idtxl.visualise_graph.</code><code class="descname">plot_network</code><span class="sig-paren">(</span><em>res</em>, <em>n_nodes</em>, <em>fdr=True</em>, <em>find_u='max_te'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_network"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_network" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of multivariate TE between processes.</p>
<p>Plot graph of the network of (multivariate) interactions between
processes (e.g., multivariate TE). The function uses  the
networkx class for directed graphs (DiGraph) internally.
Plots a network and adjacency matrix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_network()</dd>
<dt>n_nodes <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of nodes in the network</dd>
<dt>fdr <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>print FDR-corrected results (default=True)</dd>
<dt>find_u <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>use TE value (&#8216;max_te&#8217;) or p-value (&#8216;max_p&#8217;) to determine the
variable with maximum information transfer into the target in order
to determine the source-target delay (default=&#8217;max_te&#8217;)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.plot_selected_vars">
<code class="descclassname">idtxl.visualise_graph.</code><code class="descname">plot_selected_vars</code><span class="sig-paren">(</span><em>res</em>, <em>sign_sources=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#plot_selected_vars"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.plot_selected_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot network of a target process and single variables.</p>
<p>Plot graph of the network of (multivariate) interactions between
source variables and the current value. The function uses the
networkx class for directed graphs (DiGraph) internally.
Plots a network and reduced adjacency matrix.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of multivariate_te.analyse_single_target()</dd>
<dt>sign_sources <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>add only sources significant information contribution
(default=True)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>instance of a directed graph class from the networkx
package (DiGraph)</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="idtxl.visualise_graph.print_res_to_console">
<code class="descclassname">idtxl.visualise_graph.</code><code class="descname">print_res_to_console</code><span class="sig-paren">(</span><em>data</em>, <em>res</em>, <em>fdr=True</em>, <em>find_u='max_te'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/idtxl/visualise_graph.html#print_res_to_console"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#idtxl.visualise_graph.print_res_to_console" title="Permalink to this definition">¶</a></dt>
<dd><p>Print results of network inference to console.</p>
<p>Print results of network inference to console. Output looks like this:</p>
<blockquote>
<div>0 -&gt; 1, u = 2
0 -&gt; 2, u = 3
0 -&gt; 3, u = 2
3 -&gt; 4, u = 1
4 -&gt; 3, u = 1</div></blockquote>
<p>indicating significant information transfer source -&gt; target with a source-
target delay u. The network can either be plotted from FDR-</p>
<p>Source-target delays are determined by the lag of the variable in a
sources&#8217; past that has the highest information transfer into the target
process. There are two ways of idendifying the variable with maximum
information transfer:</p>
<blockquote>
<div><ol class="loweralpha simple">
<li>use the variable with the highest absolute TE value (highest
information transfer)</li>
<li>use the variable with the smallest p-value (highest statistical
significance)</li>
</ol>
</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">Data() instance</span></dt>
<dd>raw data</dd>
<dt>res <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>output of network inference algorithm, e.g., MultivariateTE</dd>
<dt>fdr <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>print FDR-corrected results (default=True)</dd>
<dt>find_u <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd>use TE value (&#8216;max_te&#8217;) or p-value (&#8216;max_p&#8217;) to determine the
variable with maximum information transfer into the target in order
to determine the source-target delay (default=&#8217;max_te&#8217;)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>numpy array</dt>
<dd>adjacency matrix describing multivariate TE between all network
nodes, entries in the matrix denote source-target-delays</dd>
</dl>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-idtxl">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-idtxl" title="Permalink to this headline">¶</a></h2>
<p>IDTxl: Information Dynamics Toolkit xl.</p>
<p>Package provides functionality for information dynamics analysis for arbitrary
data with an emphasis on the analysis of large data sets and the use of
multi-node computing clusters.</p>
</div>
</div>


                </div>
              </div>
            </div>
          </div>
        </div>
         
<div class="col-md-3 hidden-xs" id="sidebar-wrapper">
  <div class="sidebar hidden-xs" role="navigation" aria-label="main navigation">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">idtxl package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-idtxl.active_information_storage">idtxl.active_information_storage module</a></li>
<li><a class="reference internal" href="#module-idtxl.bivariate_te">idtxl.bivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.data">idtxl.data module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimator">idtxl.estimator module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_jidt">idtxl.estimators_jidt module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_opencl">idtxl.estimators_opencl module</a></li>
<li><a class="reference internal" href="#module-idtxl.estimators_pid">idtxl.estimators_pid module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_exceptions">idtxl.idtxl_exceptions module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_import">idtxl.idtxl_import module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_io">idtxl.idtxl_io module</a></li>
<li><a class="reference internal" href="#module-idtxl.idtxl_utils">idtxl.idtxl_utils module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_spectral_te">idtxl.multivariate_spectral_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.multivariate_te">idtxl.multivariate_te module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_analysis">idtxl.network_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_comparison">idtxl.network_comparison module</a></li>
<li><a class="reference internal" href="#module-idtxl.network_inference">idtxl.network_inference module</a></li>
<li><a class="reference internal" href="#module-idtxl.partial_information_decomposition">idtxl.partial_information_decomposition module</a></li>
<li><a class="reference internal" href="#module-idtxl.single_process_analysis">idtxl.single_process_analysis module</a></li>
<li><a class="reference internal" href="#module-idtxl.stats">idtxl.stats module</a></li>
<li><a class="reference internal" href="#module-idtxl.synergy_tartu">idtxl.synergy_tartu module</a></li>
<li><a class="reference internal" href="#module-idtxl.visualise_graph">idtxl.visualise_graph module</a></li>
<li><a class="reference internal" href="#module-idtxl">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/idtxl.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" role="search">
  <h3>Quick search</h3>
  <form class="search form-inline" action="search.html" method="get">
      <div class="input-append input-group">
        <input type="text" class="search-query form-control" name="q" placeholder="Search...">
        <span class="input-group-btn">
        <input type="submit" class="btn" value="Go" />
        </span>
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div> 
        
      </div><!-- /row -->

      <!-- row -->
      <div class="row footer-relbar">
<div id="navbar-related" class=" related navbar navbar-default" role="navigation" aria-label="related navigation">
  <div class="navbar-inner">
    <ul class="nav navbar-nav ">
        <li><a href="index.html">IDTxl 0.1 documentation</a></li>
    </ul>
<ul class="nav navbar-nav pull-right hidden-xs hidden-sm">
      
        <li><a href="py-modindex.html" title="Python Module Index" >modules</a></li>
        <li><a href="genindex.html" title="General Index" >index</a></li>
        <li><a href="#">top</a></li> 
      
    </ul>
  </div>
</div>
      </div><!-- /row -->

      <!-- footer -->
      <footer role="contentinfo">
          &copy; Copyright 2016, Patricia Wollstadt, Michael Wibral, Joe T. Lizier, Finn Connor, Raul Vicente.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
      </footer>
      <!-- /footer -->

    </div>
    <!-- /container -->

  </body>
</html>